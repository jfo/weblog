<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Wat is up with WebAssembly</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="https://blog.jfo.click/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta property="og:title" content="Wat is up with WebAssembly" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://blog.jfo.click/wat-is-up-with-web-assembly" />
    <meta property="og:image" content="https://blog.jfo.click/desk.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@jeffowler" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="https://blog.jfo.click">archive</a> &mdash;
        <a href="https://blog.jfo.click/feed.xml">feed</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">Wat is up with WebAssembly</h1>
        <sub>Apr 08, 2019</sub>
        <p></p>
        <div><p>I&#39;ve always been bullish on WebAssembly, and I still am. I think it has a lot
of potential to change the way we develop web applications over the long term,
and indeed to change what we consider a web application to begin with.</p>
<p>Wasm is really quite simple, in its way. The specification defines only four
numerical types and a handful of operations upon them, plus standards for
importing and exporting interfaces and shared memory buffers from and to the
surrounding context, whether that is a browser or node, and a few other things.
Of course, <a href="https://www.infoq.com/presentations/Simple-Made-Easy">simple does not mean
easy</a>, and in this case,
actually using it for anything substantial requires quite a bit of knowledge
and context on top of the specification: toolchains, conventions, standard
library polyfills for the executing context, that sort of thing.</p>
<p>That is not to say that there is no value in understanding the spec as it
exists! Quite to the contrary, I think there is great value in that. Generally,
this is how I prefer to try to learn, start from the simplest, most atomic
concepts, get a hook in, get some purchase, and then build up from there. So
let&#39;s do that. This post starts from almost nothing and builds up to slightly
more than nothing.</p>
<h2 id="in-my-various-halfhearted-attempts">In my various halfhearted attempts</h2>
<p>to understand wasm basics, I haven&#39;t had much luck. I get as far as setting up
the <a href="https://github.com/kripken/emscripten">emscripten</a> toolchain, and
compiling a <a href="https://github.com/kripken/emscripten/blob/incoming/tests/hello_world.c">hello
world</a>.</p>
<p>But alas, even the simplest thing comes out the other side of emscripten with a
dense glob of glue code all over and around it. The javascript calling context
alone is several thousand lines! I find this to be overwhelming. What are all
these autogenerated functions doing? Why are they necessary? Why can I not just
compile a simple function to wasm and see it in the binary? Emscripten is a
very powerful tool, but it was originally designed around making it possible to
compile existing projects (specifically c/c++ projects) to
<a href="http://asmjs.org/">asm.js</a> and now wasm, and as such it does a lot of work
behind the scenes to facilitate that.</p>
<p>I&#39;m interested in starting with a more stripped down and basic view of
WebAssembly. How can I understand the simplest things about it? How does it
run? Where does it run? How can I interoperate with the calling context whether
it&#39;s in a browser or a node process?</p>
<p><a href="https://webassembly.org/">https://webassembly.org/</a> has everything I need to get started with this. It
links to several of the full unabridged
<a href="https://webassembly.github.io/spec/">specifications</a>, but also has some terser
but still pretty comprehensive <a href="https://webassembly.org/docs/binary-encoding/">documentation on the binary format
here.</a> It is the latter off of
which I will be working right now. That document is not being updated since I
started this post, it points to the more comprehensive documentation instead,
but honestly I found it to be a lot easier to reason about, and it&#39;s
not <em>deprecated</em> as of 1.0, so I will refer to it here for now. The full spec
is what it says on the tin, and as such is much denser and detailed than this
simple, well written overview document.</p>
<h2 id="the-smallest-thing">The smallest thing</h2>
<p>Wasm is a <em>binary format</em>. This means that if I download a tiny <code>addTwo</code>
example from
<a href="https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html">somewhere</a>
and <code>cat</code> it, I will get something like this:</p>

<pre><code> asm       `
  addTwo
           j    name        addTwo
</code></pre>
<p>Which looks like a bunch of nothing. Opening the file in a text editor directly
is only slightly more illuminating- my vim replaces the non-printable characters
with &#39;control character&#39; cyphers meant to represent them in place.</p>

<pre><code>^@asm^A^@^@^@^A^G^A ^B^?^?^A^?^C^B^A^@^G
^A^FaddTwo^@^@
        ^A^G^@ ^@ ^Aj^K^@^Y^Dname^A     ^A^@^FaddTwo^B^G^A^@^B^@^@^A^@
</code></pre>
<p>Of course, these aren&#39;t control characters that are controlling anything, it&#39;s
just binary data.  This is not a good way to look at this file. I would like to
be able to look at the bytes directly, yes, but represented in some human
readable format. There is of course a tool for this. <code>*</code>nix systems will have
<a href="https://linux.die.net/man/1/xxd"><code>xxd</code></a> installed, a tool for working with
hexdumps.</p>
<p><code>xxd test.wasm</code> will yield:</p>

<pre><code class="lang-hex">00000000: 0061 736d 0100 0000 0107 0160 027f 7f01  .asm.......`....
00000010: 7f03 0201 0007 0a01 0661 6464 5477 6f00  .........addTwo.
00000020: 000a 0901 0700 2000 2001 6a0b 0019 046e  ...... . .j....n
00000030: 616d 6501 0901 0006 6164 6454 776f 0207  ame.....addTwo..
00000040: 0100 0200 0001 00                        .......
</code></pre>
<p>I&#39;m looking at the wasm code now, those are WebAssembly instructions that are
laid out in the specification. How can I validate that this is really a
WebAssembly module? I can actually try to use it.</p>
<p>Since late 2017, <a href="https://blog.mozilla.org/blog/2017/11/13/webassembly-in-browsers/">all the major browsers have implemented
WebAssembly</a>
but I&#39;d like to avoid the complications of running these small examples in a
browser just yet, so for now, I will use Node locally for this. Node is built
on Google&#39;s V8 engine, which is also used in Chrome, which has WebAssembly
support, so naturally, Node does too, since around version 7 I believe.</p>
<p>Let&#39;s say that I&#39;ve downloaded that <code>addTwo</code> wasm
<a href="https://cdn.rawgit.com/WebAssembly/sexpr-wasm-prototype/2bb13aa785be9908b95d0e2e09950b39a26004fa/demo/index.html">example</a> from
earlier and saved it in a file called <code>addTwo.wasm</code>. First, I&#39;ll read that local
wasm file into a variable in a node script, using the blocking synchronous
<code>readFileSync</code> for simplicity&#39;s sake:</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> buffer = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./addTwo.wasm&#x27;</span>);
</code></pre>
<p>This returns a <code>Buffer</code> containing the bytes read from the file. I can use the
globally available <code>WebAssembly</code> object to validate this buffer against the
specification.</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> isValid = <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">validate</span>(buffer);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isValid);
</code></pre>

<pre><code>true
</code></pre>
<p>As expected, it&#39;s a valid wasm file.</p>
<blockquote>
<p>This works in this case, as the node <code>Buffer</code> type is a wrapper for an
ArrayBuffer, and implements the correct interface. Many tutorials will ask
you to read the buffer into a typed array, which looks like this:</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> typedBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buf);
</code></pre>
<p>That typed array can then be passed to <code>validate</code>, <code>compile</code> or
<code>instantiate</code>. It&#39;s probably safer that way. ¯_(ツ)_/¯</p>
</blockquote>
<p>We take the buffer and compile it:</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> compiledModule = <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">compile</span>(buf); <span class="hljs-comment">// returns a Promise</span>
compiledModule.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
</code></pre>
<p>And for our trouble we receive a compiled Module.</p>

<pre><code>Module [WebAssembly.Module] {}
</code></pre>
<p>One more step! This compiled module can be instantiated using
<code>WebAssembly.Instance</code> as a constructor.</p>

<pre><code class="lang-js"><span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">compile</span>(buf).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">compiledModule</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Instance</span>(compiledModule));
});
</code></pre>

<pre><code>Instance [WebAssembly.Instance] {}
</code></pre>
<p>This <code>Instance</code> has an <code>exports</code> property which contains all of the exports of
the module. You may not be surprised then to find an <code>addTwo</code> function on this
one!</p>

<pre><code class="lang-js"><span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">compile</span>(buf).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">compiledModule</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> wasmInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title class_">Instance</span>(compiledModule);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wasmInstance.<span class="hljs-property">exports</span>); <span class="hljs-comment">// { addTwo: [Function: 0] }</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wasmInstance.<span class="hljs-property">exports</span>.<span class="hljs-title function_">addTwo</span>(<span class="hljs-number">40</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 42</span>
});
</code></pre>
<p>We&#39;re calling a wasm function!</p>
<p>Right now this takes a few steps...</p>

<ol>
<li>fetch the wasm</li>
<li>cast the resulting <code>Buffer</code> to a Uint8Array typed buffer (this seems optional but is likely good practice)</li>
<li>compile the buffer with <code>WebAssembly.compile</code></li>
<li>instantiate the Instance with <code>new WebAssembly.Instance</code></li>
</ol>
<p>The last two steps can be combined by passing the source buffer to
<code>WebAssembly.instantiate</code> instead. This function returns an object with a
<code>module</code> and a pre constructed initial <code>instance</code> on it.</p>
<p>Further, in a browser context the entire series of steps can be combined into a
single call:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming"><code>WebAssembly.instantiateStreaming</code></a>.
Node doesn&#39;t support this (yet, anyway) for <a href="https://github.com/nodejs/node/issues/21130">good
reasons</a>.</p>
<p>Let&#39;s go back to that hexdump, shall we?</p>
<p><code>xxd test.wasm &gt; test.hex &amp;&amp; vim test.hex</code></p>

<pre><code class="lang-hex">00000000: 0061 736d 0100 0000 0107 0160 027f 7f01  .asm.......`....
00000010: 7f03 0201 0007 0a01 0661 6464 5477 6f00  .........addTwo.
00000020: 000a 0901 0700 2000 2001 6a0b 0019 046e  ...... . .j....n
00000030: 616d 6501 0901 0006 6164 6454 776f 0207  ame.....addTwo..
00000040: 0100 0200 0001 00                        .......
</code></pre>
<p>What if I... change a tiny number by one? Say, incrementing that first byte...</p>

<pre><code class="lang-hex">00000000: 0161 736d 0100 0000 0107 0160 027f 7f01  .asm.......`....
00000010: 7f03 0201 0007 0a01 0661 6464 5477 6f00  .........addTwo.
00000020: 000a 0901 0700 2000 2001 6a0b 0019 046e  ...... . .j....n
00000030: 616d 6501 0901 0006 6164 6454 776f 0207  ame.....addTwo..
00000040: 0100 0200 0001 00                        .......
</code></pre>
<p>I can use <code>xxd</code> in the other direction, too, I can turn this edited <code>test.hex</code>
file back into a <code>test.wasm</code> binary file with the <code>-r</code> flag.</p>

<pre><code>xxd -r test.hex &gt; test.wasm
</code></pre>
<p>Now, back in my node script, the source is no longer valid, and attempting to
compile the source yields a verbose error:</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> buf = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.wasm&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">validate</span>(buf)); <span class="hljs-comment">// false</span>
<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(buf);
</code></pre>

<pre><code>(node:10392) UnhandledPromiseRejectionWarning: CompileError: AsyncCompile: Wasm decoding failed: expected magic word 00 61 73 6d, found 01 61 73 6d @+0
</code></pre>
<p>Well, that makes sense.</p>
<h2 id="the-smallest-thing">The smallest thing</h2>
<p>Forget <code>addTwo</code>. What&#39;s the absolute smallest valid WebAssembly binary?</p>
<p>First of all, let&#39;s make it easier to edit these hexdumps. <code>xxd -p test.wasm &gt; test.hex</code> will remove
the extra information and leave us with only the &quot;bytes.&quot;</p>

<pre><code class="lang-hex">0061736d0100000001070160027f7f017f03020100070a01066164645477
6f00000a09010700200020016a0b0019046e616d65010901000661646454
776f020701000200000100
</code></pre>
<p>I&#39;m going to remove <em>everything</em> except for the first 8 bytes.</p>

<pre><code class="lang-hex">0061736d01000000
</code></pre>
<p>This is the smallest possible valid wasm binary, consisting of the magic number
<code>\x00asm</code> and the WebAssembly version number (version 1) in <a href="https://en.wikipedia.org/wiki/Endianness">little
endian</a> format.</p>
<p><code>xxd -r -p test.hex &gt; test.wasm</code></p>
<p>and now:</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> buf = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.wasm&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">validate</span>(buf))
</code></pre>

<pre><code>true
</code></pre>
<p>I am editing these bytes about as directly as I could be, but I am still seeing
textual symbols in the text editor to represent them. Obviously, I must do it
this way, but it&#39;s interesting to note that here, <code>xxd</code> is acting as an
extremely bare bones compiler- taking source code (the hexdump text) and
turning it into machine code (by simply translating the hexadecimal bytes into
their actual numerical values and writing that to disk.) It&#39;s not that doing
much of anything we usually think of as &quot;compilation,&quot; no analysis or
optimization or transformations or any of those things, but nevertheless, it
compiling- translating code from one form to another.</p>
<blockquote>
<p>You may be tempted to call this a &quot;transpiler&quot; instead, which I would like to
<a href="http://decomposition.al/blog/2017/07/30/what-do-people-mean-when-they-say-transpiler/">discourage</a>.</p>
</blockquote>
<p>Here, I will add comments. The <code>sed</code> command will filter out everything after a
<code>#</code> to the end of that line, and then I pass the result to the xxd command from
before:</p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number
</code></pre>

<pre><code>sed &#39;s/\#.*$//&#39; test.hex | xxd -r -p &gt; test.wasm
</code></pre>
<p>Maybe this is the world&#39;s simplest compiler.</p>
<h2 id="hello-single-static-global-variable-world">Hello single static global variable world</h2>
<p>Now it&#39;s time to refer to the <a href="https://webassembly.org/docs/binary-encoding/">binary specification
overview</a>.  I won&#39;t rehash
everything on that page, the only thing more thorough is the official spec
itself. Following along from &quot;High-level structure&quot;, we can see that after the
magic number / version number preamble, a well formed module will have a
sequence of sections.</p>
<blockquote>
<p>&quot;The module preamble is followed by a sequence of sections. Each section is
identified by a 1-byte section code that encodes either a known section or a
custom section. The section length and payload data then follow.&quot;</p>
</blockquote>
<p>There are 11 standard sections, and a mechanism for creating arbitrarily named sections.</p>
<blockquote>
<p>Each known section is optional and may appear at most once. Custom sections all
have the same id (0), and can be named non-uniquely (all bytes composing their
names may be identical).  Custom sections are intended to be used for debugging
information, future evolution, or third party extensions. For MVP, we use a
specific custom section (the Name Section) for debugging information.</p>
</blockquote>
<p>I want to start by picking a simple section and implementing it in bytecode.
The <code>global</code> section is a good candidate for this, because it has no dependency
on any other sections and is fairly straightforward in its utility. This
section is used to declare globally available variables within the module.
Let&#39;s take another look at that hexfile! I&#39;ll need to add the id and the
payload length for the global section.</p>
<p>Per the spec, these two are typed as <code>varuint7</code> and <code>varuint32</code>, respectively,
which you can read as &quot;variable unsigned integer <em>n</em>&quot; where <em>n</em> is the maximum
amount of bits encoded. A <code>varuint7</code> can only be one byte long, but a
<code>varuint32</code> can be <em>up to</em> 4 bytes long, but <em>doesn&#39;t have to be</em>. They are
<a href="https://en.wikipedia.org/wiki/LEB128">Little Endian Base 128</a> types.</p>
<p>The <code>id</code> for the global section is <code>6</code>, and the length is as yet unknown, so I
will placehold it with <code>0</code></p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number

06  # global section id
00  # global section payload length
</code></pre>
<p>I will fill in the length differently as I go along to keep up with the actual length.</p>
<p>Now, what actually goes into the global section? It consists of a count of all
the globals followed by a series of glabal declarations. I want to make just one!</p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number

06  # global section id
00  # global section payload length
01  # globals count
</code></pre>
<p>Now, what actually goes into a global entry? a <em>type declaration</em> followed by a
<em>mutability flag</em> set to 0 or 1 (for false or true respectively), and an
initialization expression.</p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number

06  # global section id
00  # global section payload length
01  # globals count
7f  # i32 type declaration
00  # mutability
</code></pre>
<p>Now, what actually goes into an initialization expression? In the mvp, you may
<a href="https://webassembly.org/docs/semantics/#constants">only declare a global variable immediately as a constant <em>or</em> grab it from an
import</a>. I&#39;ll go for the
first option. This means we use the bytecode for <code>i32.const</code>, which is <code>41</code>,
followed by a literal value, and ending with the opcode for <code>end</code> as a
delimiter. All of these bytecodes are described in detail on the <a href="https://webassembly.org/docs/binary-encoding/">docs
page</a>, although they can be a
little tough to follow/untangle, they are all there.</p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number

06  # global section id
06  # global section payload length
01  # globals count
7f  # i32 type declaration
00  # mutability
41  # i32.const
2a  # i32 literal
0b  # end
</code></pre>
<p>Note that I&#39;ve updated the payload length to be <code>06</code> now.</p>
<p>So, that&#39;s it! This should be a valid wasm module. Is it?</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> buf = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.wasm&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">validate</span>(buf))
</code></pre>

<pre><code>true
</code></pre>
<p>And yes it is.</p>
<p>How does this look different from the first example? Well, the eventual
compiled instance will probably be slightly bigger (or perhaps, if the global
is immutable, the compiler will reference some internal canonical value, I
don&#39;t know how the internals work). But from the perspective of the consumer of
this module, nothing about the interface changes. &quot;Global&quot; means global <em>to the
module</em>. There is one more step to expose the value, and that is by referencing
it in the <a href="https://webassembly.org/docs/binary-encoding/#export-section"><code>exports</code> section</a>.</p>

<pre><code class="lang-hex">0061736d  # magic number
01000000  # wasm version number

06  # global section id
06  # global section payload length
01  # globals count
7f  # i32 type declaration
00  # mutability
41  # i32.const
2a  # i32 literal
0b  # end

07  # export section id
05  # export section payload length
01  # export section count
01  # field string (name) length
78  # field string (name) - here 78 is the char code for the letter &#39;x&#39;
03  # kind (global)
00  # memaddr
</code></pre>
<p>Now, from the node script, I can see that global as an export named &quot;x&quot;</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> buf = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.wasm&#x27;</span>);
<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(buf).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>)
})
</code></pre>

<pre><code>{ x: 42 }
</code></pre>
<h2 id="wat-">Wat?</h2>
<p>As you can see, it is entirely possible to produce functioning wasm by hand,
and I could continue the exercise in this way. There is some value in
understanding how to read the <em>bytes themselves</em>, but this isn&#39;t really a
sustainable workflow for a lot of reasons. Most obviously, any substantial real
program would be impenetrable.</p>
<p>Luckily, the WebAssembly spec includes a <em>textual encoding</em> using
<a href="https://en.wikipedia.org/wiki/S-expression">s-expressions</a>. This format is
much easier to both read and to write, and also the file suffix is <code>wat</code>, which
is terrific. <code>wat</code> uses s-expressions, but it is not a lisp. Lisps are also
based around s-expressions, but the things that make a lisp a lisp are how the
s-expressions are stored and evaluated, not the format alone.</p>
<p>The <a href="https://github.com/WebAssembly/wabt">WebAssembly binary toolkit</a> includes
among its many tools a couple of utilities to translate between wasm and wat in
both directions. They are unceremoniously named <code>wasm2wat</code> and <code>wat2wasm</code>.</p>
<p>So what does my test file look like in <code>wat</code>?</p>

<pre><code>$ wasm2wat test.wasm
</code></pre>

<pre><code class="lang-wat">(module
  (global (;0;) i32 (i32.const 42))
  (export &quot;x&quot; (global 0)))
</code></pre>
<p>This should look structurally familiar, it&#39;s essentially a 1:1 match to the
bytecode with a couple of small exceptions.</p>
<p><code>module</code> defines a top level s-expression for the module, just like the
preamble with the magic number and version number does.</p>
<p>You&#39;ll also notice <code>(;0;)</code>, which is a comment that <code>wasm2wat</code> has inserted to help
with identifying the memory address of the global declaration. See that it is
referred to in the <code>export</code> section as <code>0</code>.  Globals are always referred to by
their memory address in the order they were declared, so you could see how this
would become unwieldy with a lot of them. If you run <code>wat2wasm</code> on this output,
you will get back exactly what was put in.</p>
<p>From this base, I can start exploring the other sections in the module spec and
investigating how wasm could be and already is used in the real world. Some
questions I would like to explore in further post:</p>

<ul>
<li>How does wasm interact with the calling context when passing complex values like javascript objects?</li>
<li>What really <em>is</em> the interop overhead when passing large amounts of data between js and wasm? When does taking on that overhead make sense for the greater application performance?</li>
<li>Are the current use cases, toolchains, and possibilities of wasm mature enough, and/or compelling enough, to drive its adoption in a meaningful way in the future?</li>
<li>I haven&#39;t touched on this, but wasm as currently conceived is absolutely not intended to replace javascript. But could it potentially do that someday in the far future? Browser apis would have to be fully exposed and source language compilers and standard libraries would have to implement support for those apis on a per language basis, but it could be done. Is this something we want to work towards?</li>
</ul>
<p>All this and more coming to you in my very next post in ::<em>checks post history</em>:: mid 2020.</p>
</div>
      </article>
    </div>

    <script async defer src="https://analytics.jfo.click/latest.js"></script>
    <noscript
      ><img src="https://analytics.jfo.click/noscript.gif" alt=""
    /></noscript>
  </body>
</html>
