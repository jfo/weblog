<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>making-sounds2</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="http://dev.jfo.click:4321/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="http://dev.jfo.click:4321">archive</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">making-sounds2</h1>
        <sub>Jan 01, 1970</sub>
        <p></p>
        <div><p>Here, I&#39;m indexing against the array of natural notes from earlier. This is
pretty unwieldy, and I&#39;m missing the chromatic notes, which is very limiting.
Instead, I can define numerical constants that will be interpolated by the
preprocessor as the floats that I want to pass in. That will look something like this:</p>

<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _C1 213.383</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _Db1 243.383</span>
<span class="hljs-comment">// etc...</span>
</code></pre>
<p>We have the note letter name, the octave (0-8) that it is in, and the
frequency that the constant will map to. I&#39;m prefixing them with an <code>_</code> to
avoid conflicts with predefined constants in the Arduino standard library.</p>
<p>I&#39;m not going to paste all this in there, but I am going to make a header file
for it and include it in my arduino sketch to allow me to use all of these
labels in my song code.</p>
<p><a href="https://github.com/urthbound/soundfromnowhere/blob/master/player/notes.h" target="_blank">It&#39;s here, if you&#39;re curious!</a></p>
<p>Here&#39;s another melody, using those constants:</p>

<pre><code class="lang-c"><span class="hljs-type">float</span> buddy_holly[<span class="hljs-number">49</span>][<span class="hljs-number">2</span>] = {
    {_Ab3,    <span class="hljs-number">500.0</span>}, {_F4,    <span class="hljs-number">500.0</span>}, {_Eb4,   <span class="hljs-number">500.0</span>}, {_C4,     <span class="hljs-number">250.0</span>},
    {_Ab3,    <span class="hljs-number">250.0</span>}, {_Bb3,   <span class="hljs-number">250.0</span>}, {_C4,    <span class="hljs-number">250.0</span>}, {_Bb3,    <span class="hljs-number">250.0</span>},
    {_Ab3,    <span class="hljs-number">250.0</span>}, {_F3,    <span class="hljs-number">500.0</span>}, {_Eb3,   <span class="hljs-number">500.0</span>}, {_REST,   <span class="hljs-number">500.0</span>},
    {_F4,     <span class="hljs-number">500.0</span>}, {_Eb4,   <span class="hljs-number">500.0</span>}, {_C4,    <span class="hljs-number">250.0</span>}, {_Ab3,    <span class="hljs-number">250.0</span>},
    {_Bb3,    <span class="hljs-number">250.0</span>}, {_C4,    <span class="hljs-number">250.0</span>}, {_Bb3,   <span class="hljs-number">250.0</span>}, {_Ab3,    <span class="hljs-number">250.0</span>},
    {_Bb3,    <span class="hljs-number">500.0</span>}, {_REST,  <span class="hljs-number">500.0</span>}, {_F3,    <span class="hljs-number">500.0</span>}, {_G3,     <span class="hljs-number">500.0</span>},
    {_Ab3,    <span class="hljs-number">500.0</span>}, {_Bb3,   <span class="hljs-number">250.0</span>}, {_C4,    <span class="hljs-number">250.0</span>}, {_F3,     <span class="hljs-number">250.0</span>},
    {_F3,     <span class="hljs-number">250.0</span>}, {_Eb3,   <span class="hljs-number">250.0</span>}, {_Eb3,   <span class="hljs-number">250.0</span>}, {_Eb3,    <span class="hljs-number">125.0</span>},
    {_F3,     <span class="hljs-number">125.0</span>}, {_Ab3,   <span class="hljs-number">250.0</span>}, {_REST,  <span class="hljs-number">500.0</span>}, {_Ab3,    <span class="hljs-number">500.0</span>},
    {_F4,     <span class="hljs-number">500.0</span>}, {_Eb4,   <span class="hljs-number">250.0</span>}, {_C4,    <span class="hljs-number">500.0</span>}, {_REST,   <span class="hljs-number">250.0</span>},
    {_Ab3,    <span class="hljs-number">500.0</span>}, {_REST, <span class="hljs-number">1500.0</span>}, {_Ab3,   <span class="hljs-number">500.0</span>}, {_F4,     <span class="hljs-number">500.0</span>},
    {_Eb4,    <span class="hljs-number">250.0</span>}, {_C4,    <span class="hljs-number">500.0</span>}, {_REST,  <span class="hljs-number">250.0</span>}, {_Ab3,    <span class="hljs-number">500.0</span>},
    {_REST,  <span class="hljs-number">1500.0</span>}
};
</code></pre>
<p>TODO: buddy holly</p>
<p>If you&#39;ll notice, we&#39;re passing in absolute durations in milliseconds for each
note. This is also kind of unwieldy, unmusical, and hard to change. A more
musical way of approaching this would be to mark each note with a constant
representing a duration, and then modifying the existing ancillary functions to
process that into the appropriate duration given a global tempo.</p>
<p>I can define an <code>enum</code> in one of my header files to provide me with the &#39;marks&#39;:</p>

<pre><code class="lang-c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">durs</span> =</span> { SIXTEENTH, EIGHTH, DOTTED_EIGHTH, QUARTER, DOTTED_QUARTER, HALF, WHOLE }
</code></pre>
<p>An <code>enum</code> is a shorthand way to define numerical constants in C/C++. The above
could be written as:</p>

<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIXTEENTH       0</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> EIGHT           1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DOTTED_EIGHT    2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> QUARTER         3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DOTTED_QUARTER  4</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF            5</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WHOLE           6</span>
</code></pre>
<p>As with the note macros defined above, the C preprocessor interpolates these
integer values wherever it sees its associated token. So <code>EIGHTH</code> becomes <code>0</code>,
and <code>0</code> is what the compiler actually sees.</p>
<p>Now I can add a <code>tempo</code> argument to the <code>play_melody()</code> function, and define a
helper function that computes the value of a rhythmic duration at a given
tempo. Lickity split!</p>

<pre><code class="lang-c"><span class="hljs-type">int</span> <span class="hljs-title function_">note_duration</span><span class="hljs-params">(<span class="hljs-type">int</span> rhythmic_value, <span class="hljs-type">int</span> tempo)</span> {
    <span class="hljs-comment">// 60000ms in a minute, divided by the tempo in beats per minutes, gives us</span>
    <span class="hljs-comment">// the absolute duration of a single beat. From there, dividing and</span>
    <span class="hljs-comment">// multiplying the beat will return the durations of related rhythmic values.</span>

    <span class="hljs-type">int</span> one_beat = <span class="hljs-number">60000</span> / tempo

    <span class="hljs-keyword">switch</span> (rhythmic_value) {
        <span class="hljs-keyword">case</span> : SIXTEENTH
            <span class="hljs-keyword">return</span> one_beat / <span class="hljs-number">4</span>;
        <span class="hljs-keyword">case</span> : EIGHTH
            <span class="hljs-keyword">return</span> one_beat / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">case</span> : DOTTED_EIGHTH
            <span class="hljs-title function_">return</span> <span class="hljs-params">(one_beat / <span class="hljs-number">2</span>)</span> * 1.5;
        <span class="hljs-keyword">case</span> : QUARTER
            <span class="hljs-keyword">return</span> one_beat;
        <span class="hljs-keyword">case</span> : DOTTED_QUARTER
            <span class="hljs-keyword">return</span> one_beat * <span class="hljs-number">1.5</span>;
        <span class="hljs-keyword">case</span> : HALF
            <span class="hljs-keyword">return</span> one_beat * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">case</span> : WHOLE
            <span class="hljs-keyword">return</span> one_beat * <span class="hljs-number">4</span>;
    }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">play_melody</span><span class="hljs-params">(<span class="hljs-type">float</span> melody[][<span class="hljs-number">2</span>], <span class="hljs-type">size_t</span> size_of_melody, <span class="hljs-type">int</span> tempo)</span> {

    <span class="hljs-type">int</span> dur = note_duration(melody[i][<span class="hljs-number">1</span>], tempo)

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size_of_melody / (<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">2</span>); i++) {
        square_wave(melody[i][<span class="hljs-number">0</span>], dur);
    }
}
</code></pre>
<p>Now we can represent these notes as a collection of tuples, that semantically
make a little more sense.</p>
<p>instead of <code>{440.0, 500.0}</code> to represent an A natural quarter note, we can
write something like <code>{_A4, QUARTER}</code> and pass in a global tempo instead of
doing each note duration by hand.</p>
<p>Here&#39;s how a melody looks in these tuples:</p>

<pre><code class="lang-c"><span class="hljs-type">float</span> happy_birthday[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>] = {
    { _Db3, DOTTED_EIGHTH }, { _Db3, SIXTEENTH }, { _Eb3, QUARTER }, { _Db3, QUARTER }, { _Gb3, QUARTER }, { _F3, HALF },
    { _Db3, DOTTED_EIGHTH }, { _Db3, SIXTEENTH }, { _Eb3, QUARTER }, { _Db3, QUARTER }, { _Ab3, QUARTER }, { _Gb, HALF },
    { _Db3, DOTTED_EIGHTH }, { _Db3, SIXTEENTH }, { _Db4, QUARTER }, { _Bb3, QUARTER }, { _Gb3, QUARTER }, { _F3, QUARTER }, { _Eb3, QUARTER },
    { _B3, DOTTED_EIGHTH }, { _B3, SIXTEENTH }, { _Bb3, QUARTER }, { _Gb3, QUARTER }, { _Ab3, QUARTER }, { _Gb3, HALF }, { REST, QUARTER }
}

loop() {
    play_melody(happy_birthday, <span class="hljs-keyword">sizeof</span>(happy_birthday), <span class="hljs-number">120</span>);
    play_melody(happy_birthday, <span class="hljs-keyword">sizeof</span>(happy_birthday), <span class="hljs-number">160</span>);
    delay(<span class="hljs-number">1000</span>);
}
</code></pre>
<p>This little instrument never gets tired. It doesn&#39;t need to breath, and it can
play notes faster than we can hear them, because you know, it&#39;s a computer:</p>
<p><img src="https://media.giphy.com/media/5fBH6zxifuuoKgTKB3O/giphy.gif" alt="Hey kid!"></p>

<pre><code>nonsense computer noise notes with duration at 1μs or something.
</code></pre>
<p>Not bad for starting from scratch.</p>

<pre><code class="lang-c">flight of the bumble bee
</code></pre>
<p>There is a problem with our design! We can&#39;t control the relative volume of the
notes that we are producing. This is not ideal; dynamics are responsible for a
huge amount of the expressivity of music, and if we&#39;re trying to make something
that can produce music, we should be concerned about that.</p>
<blockquote>
<p>Computer music isn&#39;t often thought of as &quot;expressive&quot;, but I&#39;d invite you to
consider the fact that when you listen to a recording of a piece that really
gets to you, you are actually hearing a representation of an event produced by
the same electronics that, in a vacuum, invite criticism of unemotional-ness.</p>
</blockquote>
<p>So, we need to figure out a way to modulate how much energy is being sent to
the speaker! Up until now I&#39;ve been using a digital output pin which can
only output <code>HIGH</code> and <code>LOW</code>, essentially 1 or 0, which on the Arduino Uno is 5
volts for <code>HIGH</code> and 0 volts for <code>LOW</code></p>
<p>Some cursory googling will reveal an arduino library function named
<a href="https://www.arduino.cc/en/Reference/AnalogWrite"><code>analogWrite()</code></a>, which would
appear to be <em>exactly</em> what we need, so [spoiler alert, it is not what we need
but] let&#39;s try it out [anyway]!</p>
<p>I can adjust the code from the very first wave example from before from:</p>

<pre><code class="lang-c"><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> {
    digitalWrite(OUTPIN, HIGH);
    delayMicroseconds(<span class="hljs-number">1136</span>);
    digitalWrite(OUTPIN, LOW);
    delayMicroseconds(<span class="hljs-number">1136</span>);
}
</code></pre>
<p>to:</p>

<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUTPIN [an analog pin no]</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> {
    analogWrite(OUTPIN, <span class="hljs-number">255</span>);
    delayMicroseconds(<span class="hljs-number">1136</span>);
    analogWrite(OUTPIN, <span class="hljs-number">0</span>);
    delayMicroseconds(<span class="hljs-number">1136</span>);
}
</code></pre>
<p>TEST WHETHER HIGH AND LOW WORK at all</p>
<p>[Though we can use the <code>HIGH</code> and <code>LOW</code> constants here if we want to], it&#39;s
more instructive to skip that step and show the equivalent <code>255</code> for <code>HIGH</code> and
<code>0</code> for <code>LOW</code>. Notice also that I&#39;ve changed the outpin; only some of the pins
on the board support this operation, some of them are digital only pins.
<code>analogWrite()</code> takes an integer between 0 and 255 (that&#39;s a one
byte value for those playing along at home) and outputs an analog equivalent
voltage between 0v and 5v. Like I said, sounds like exactly what I
wanted! Given that, this code should play the same tone at about half the
volume:</p>

<pre><code class="lang-c"><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> {
    analogWrite(OUTPIN, <span class="hljs-number">127</span>);
    delayMicroseconds(<span class="hljs-number">1136</span>);
    analogWrite(OUTPIN, <span class="hljs-number">0</span>);
    delayMicroseconds(<span class="hljs-number">1136</span>);
}
</code></pre>
<p>And here, it does:</p>
<p>GROSS</p>
<p>Wait no it doesn&#39;t wtf?!</p>
<h2 id="why-this-doesn-t-work">Why this doesn&#39;t work</h2>
<p>Arduino&#39;s <code>analogWrite()</code>-able pins use a technique called &#39;pulse width
modulation&#39;, or PWM, to approximate analog output. If you send <code>0</code> or <code>255</code> as
the value, it does the same this that <code>digitalWrite()</code> does for <code>HIGH</code> and
<code>LOW</code>, respectively.  any number in between, though, and it oscillates between
0 and 255 very very quickly, and adjusts the <em>duty cycle</em> of the output to
approximate an analog value.</p>
<p>So, if I output a steady <code>analogWrite(127)</code> like this:</p>

<pre><code class="lang-c"><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> {
    analogWrite(OUTPIN, <span class="hljs-number">127</span>);
}
</code></pre>
<p>I&#39;m actually outputting <code>255</code>, or <code>HIGH</code>, half the time, and <code>LOW</code>, or <code>0</code>, the
other half of the time. Similarly, some value like <code>analogWrite(50)</code> would be
<code>HIGH</code> <em>about</em> 1/5th of the time and <code>LOW</code> 4/5ths of the time. They would look like this:</p>
<p>PHOTO</p>
<p>If this sounds familiar, it&#39;s because it is doin exactly the same thing as we
are manually doing when we are creating a wave!  The &#39;pulse&#39; in &#39;pulse width
modulation&#39; <em>is a square wave itself</em>. You might be able to guess now, why the
&quot;analog&quot; output of out wave above wasn&#39;t working, because the wave we&#39;re trying
to output is interfering with the <em>carrier wave</em> of the pulse width modulation.</p>
<p>On an arduino uno&#39;s &#39;analog&#39; pins, 490hz. is the standard carrier wave, so if
we just <code>analogWrite(127);</code> continuously, like above, we can hear that
frequency come out of the speaker:</p>
<p>This works great for lights, because our eyes aren&#39;t sensitive enough to notice
the flickering, and we perceive it as a dimmed light.</p>
<p>It also works for motors:</p>
<p>which move too slowly to physically react to the the rapid oscillations.</p>
<p>Our ears, though, are particularly sensitive to oscillations in this range, and
the speaker itself is extremely sensitive to the changes as well. There are
clever ways to get around this... you can set the carrier wave frequency to be
high above human hearing range (which is, at most, ~20Hz to ~20000Hz) for
example.  At 60000Hz, the pulse width effect can be achieved without being
audible. This is awesome! But I&#39;m interested in true digital to analog
conversion, so I&#39;m going to do something else.</p>
<hr>

<p>Instead of a PWM, let&#39;s explore a thing called an R2R resistance ladder, which looks like this:</p>
<p>This turns out to be a really clean way to turn multiple-bit binary output into
an <em>actually analog</em> amount of voltage between whatever <code>HIGH</code> and <code>LOW</code> is.</p>
<p>Here&#39;s how it works. It has 8 digital inputs, and 1 analog output. The first
input goes through three resistors, effectively halving it&#39;s output. So if it&#39;s
outputting a steady stream of 5v, after going through those two resistors it
would be outputting 2.5v. The next input goes through these same 3 resistors,
but <em>also</em> goes through two more, halving that as well, <em>again</em>. The first, or
<em>most significant bit</em> input is worth 2.5v, and the second most significant bit
input is worth 1.25v. Stopping there, with a two bit version, we could
potentially output any of these 4 values:</p>

<pre><code>00 = 0v
01 = 1.25v
10 = 2.5v
11 = 3.75v
</code></pre>
<p>The more bits we have, the higher the resolution of our output and the more
precise we can be, by using different combinations of the output pins. I&#39;m
attempting an 8 bit analog output, which would mean the eight pins would be
worth about this much each (zero indexed):</p>

<pre><code>0 = 2.5 volts
1 = 1.25 volts
2 = 0.625 volts
3 = 0.3125 volts
4 = 0.15625 volts
5 = 0.078125 volts
6 = 0.0390625 volts
7 = 0.01953125 volts
</code></pre>
<p>but we have to either compute the next sample in a series, OR use a wavetable,
OR send in values from an external source (need to use buffers, etc)</p>
<p>maybe mention max mathews and his paper here at some point (-1..1) thing</p>
<p>can we now send a midi file through to the arduino?</p>
<p>maybe now we switch over</p>
</div>
      </article>
    </div>

  </body>
</html>
