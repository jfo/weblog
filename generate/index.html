<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>generate</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="http://dev.jfo.click:4321/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="http://dev.jfo.click:4321">archive</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">generate</h1>
        <sub>Jan 01, 1970</sub>
        <p></p>
        <div><p>I&#39;m going to write a blog generator. Let&#39;s dispense with the &quot;why.&quot;</p>
<p>This blog has been, in order, wordpress, middleman, jekyll, and hugo. Each time
I become comfortable with one, inevitably they will become too slow for my
needs (jekyll) or introduce breaking changes into some major version or
another, offering me an opportunity to jump ship (middleman and hugo) or just
be not fit for purpose / total overkill (wordpress). I am tired of migrating
every few years to get a random feature or please the platform. So I&#39;ll write
my own. How hard can it be? Not that hard, really, as it turned out.</p>
<p>What are the benefits?</p>
<p><em>Configurability</em>. I will no longer need to appease changelogs driven by someone(s)&#39;
elses&#39; priorities, whatever they are. I can include the features I need and not
the ones that I don&#39;t. You can&#39;t get much more configurable than &quot;roll your own&quot; after all.</p>
<p><em>Stability</em>. The generator will change when I want it to. I&#39;ll have to keep up
with platform changes, like version bumps in the runtime, but that happens with
much more pomp and circumstance and more infrequently than package updates.</p>
<p><em>The learns</em>. As always.</p>
<p>Let&#39;s get started, then.</p>
<h1 id="what-is-a-static-site-generator-">What is a static site generator?</h1>
<p>A static site generator is <em>basically</em> a compiler, right? We take an input (the
source) transform it somehow and output it in some other form. This is a loose
usage of &quot;compile&quot; but I&#39;ll stand by the general idea. Usually this is markdown -&gt; html.</p>
<p>I love markdown, <a href="https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">in spite of its troubled
past</a>.
It&#39;s easy to read and write in its raw form, and as long as you don&#39;t expect it
to do everything html can do seamlessly and can live with the occasional
weirdness, it&#39;s fine.</p>
<p>You could sit down and write a whole post directly in html, but there are some
pretty obvious downsides to that.</p>

<ol>
<li><p><strong>It sucks.</strong> It&#39;s hard to do, error prone, and adds extra work. Writing is
already a lot of work.  I don&#39;t want to be farting around with mysteriously
unclosed <code>div</code>s.</p>
</li>
<li><p><strong>It&#39;s not flexible.</strong> Markdown is a type of standardized source, and it can
thus be <a href="https://pandoc.org/MANUAL.html">turned into differently formatted
targets</a>.  Sure, so can html, but we&#39;ve
established that writing in html sucks, so why not use markdown?</p>
</li>
<li><p>I&#39;m used to it. YMMV.</p>
</li>
</ol>
<p>So start with this: I want a program that takes <em>as input</em> some markdown and
<em>outputs</em> some html.</p>
<p>What am I going to write it in? I&#39;ve been wanting to try Deno out for a few
years, so <a href="https://deno.land/">I&#39;m going to try something new.</a></p>

<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/markdown@v2.0.0/mod.ts&quot;</span>;

<span class="hljs-keyword">const</span> sourcetext = <span class="hljs-string">&quot;This is a string of markdown.&quot;</span>;
<span class="hljs-keyword">const</span> output = <span class="hljs-title class_">Marked</span>.<span class="hljs-title function_">parse</span>(sourcetext);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output);
<span class="hljs-comment">// { content: &quot;&lt;p&gt;This is a string of markdown.&lt;/p&gt;\n&quot;, meta: {} }</span>
</code></pre>
<p>So here is a program that takes in a source and outputs markdown. I am pulling
my only dependency directly from <code>https://deno.land/x</code>. This is an officially
hosted site for third party packages, of which there are quite a few high
quality ones already, many but not all of them being ports of npm packeges.</p>
<p>You&#39;ll notice that the <code>output</code> turns out to be an object with the expected
<code>content</code>, but what is <code>meta</code>? It turns out this is quite useful for a blog
generator, as out of the box this markdown implementation supports parsing YAML
frontmatter.</p>
<p>I ran this from the CLI by using <code>deno run filename.js</code>.</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/markdown@v2.0.0/mod.ts&quot;</span>;

<span class="hljs-keyword">const</span> sourcetext = <span class="hljs-string">`
---
title: &#x27;This is a title&#x27;
---

This is a string of markdown.
`</span>;
<span class="hljs-keyword">const</span> output = <span class="hljs-title class_">Marked</span>.<span class="hljs-title function_">parse</span>(sourcetext);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output);
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//  content: &quot;&lt;p&gt;This is a string of markdown.&lt;/p&gt;\n&quot;,</span>
<span class="hljs-comment">//  meta: { title: &quot;This is a title&quot; }</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>Frontmatter is at this point a pretty standard method for getting metadata
attached to source markdown files in a static generator, all the way back to at
least <a href="https://jekyllrb.com/">Jekyll</a>. This obviates any need to keep some kind
of index or central database of that metadata, and since it&#39;s completely
arbitrary what I put in there, this will offer a lot of flexibility when it comes
time to add f.ex tagging or syndication etc.</p>
<p>Next step is fairly obvious, I&#39;d like to read in a file and apply this parsing
to it. Let&#39;s pretend that file contains the string in <code>sourcetext</code>, above.</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/markdown@v2.0.0/mod.ts&quot;</span>;

<span class="hljs-keyword">const</span> input = <span class="hljs-title class_">Deno</span>.<span class="hljs-title function_">readTextFileSync</span>(<span class="hljs-string">&#x27;./sourcetext.md&#x27;</span>);
<span class="hljs-keyword">const</span> output = <span class="hljs-title class_">Marked</span>.<span class="hljs-title function_">parse</span>(input);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output);
</code></pre>
<p>This breaks.</p>

<pre><code>error: Uncaught PermissionDenied: Requires read access to &quot;./sourcetext.md&quot;, run again with the --allow-read flag
const input = Deno.readTextFileSync(&quot;./sourcetext.md&quot;);
                   ^
    at deno:core/01_core.js:106:46
    at unwrapOpResult (deno:core/01_core.js:126:13)
    at Object.opSync (deno:core/01_core.js:140:12)
    at openSync (deno:runtime/js/40_files.js:37:22)
    at Object.readTextFileSync (deno:runtime/js/40_read_file.js:30:18)
</code></pre>
<p>Deno is <a href="https://deno.land/manual/getting_started/permissions">&quot;secure by default&quot;</a>. It takes a
sandbox model of security in the same way that browser runtimes do, so if you
want to give it access to your filesystem, you have to do so explicitly.</p>

<pre><code>deno run --allow-read filename.js
</code></pre>
<p>This works.</p>
<p>I&#39;m using the <code>sync</code> version of the file reading function here, for simplicity.
I&#39;m used to Node, where for scripting it&#39;s easiest to just use synchronous I/O
for smaller scripts. I&#39;ll come back to this later to discuss top level-awaits,
which are genuinely exciting to me.</p>
<p>Of course, I don&#39;t just want to print the output to the console, I want to
produce some html from the source.</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/markdown@v2.0.0/mod.ts&quot;</span>;
<span class="hljs-keyword">import</span> { paramCase } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/case/mod.ts&quot;</span>;

<span class="hljs-keyword">const</span> input = <span class="hljs-title class_">Deno</span>.<span class="hljs-title function_">readTextFileSync</span>(<span class="hljs-string">&quot;./sourcetext.md&quot;</span>);
<span class="hljs-keyword">const</span> output = <span class="hljs-title class_">Marked</span>.<span class="hljs-title function_">parse</span>(input);

<span class="hljs-title class_">Deno</span>.<span class="hljs-title function_">writeTextFileSync</span>(
  <span class="hljs-string">`./<span class="hljs-subst">${paramCase(output.meta.title)}</span>.html`</span>,
  output.<span class="hljs-property">content</span>
);
</code></pre>
<p>Notice again I&#39;m importing a helper module, this time to do some case
manipulation so that I can produce a url ready filename from the metadata.</p>
<p>This also breaks. I need explicit write access, too, and it is separate.</p>

<pre><code>deno run --allow-read --allow-write filename.js
</code></pre>
<p>This works.</p>
<p>If you&#39;re thinking that we&#39;re already frighteningly close to a full-fledged
static site generator, well then you&#39;d be mostly right.</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {
  ensureDirSync,
  expandGlobSync,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/std@0.91.0/fs/mod.ts&quot;</span>;
<span class="hljs-keyword">import</span> { paramCase } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/case/mod.ts&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://deno.land/x/markdown@v2.0.0/mod.ts&quot;</span>;

<span class="hljs-comment">// We create the output directory:</span>
<span class="hljs-title function_">ensureDirSync</span>(<span class="hljs-string">&quot;./build&quot;</span>);

<span class="hljs-keyword">const</span> inputFiles = <span class="hljs-title function_">expandGlobSync</span>(<span class="hljs-string">&quot;**/*.md&quot;</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> inputFiles) {
  <span class="hljs-keyword">const</span> input = <span class="hljs-title class_">Deno</span>.<span class="hljs-title function_">readTextFileSync</span>(file.<span class="hljs-property">path</span>);

  <span class="hljs-comment">// We write the file processed through markdown:</span>
  <span class="hljs-keyword">const</span> markup = <span class="hljs-title class_">Marked</span>.<span class="hljs-title function_">parse</span>(input);
  <span class="hljs-title class_">Deno</span>.<span class="hljs-title function_">writeTextFileSync</span>(
    <span class="hljs-string">`./build/<span class="hljs-subst">${paramCase(markup.meta.title)}</span>.html`</span>,
    markup.<span class="hljs-property">content</span>,
  );
}
</code></pre>
<p>This script (which is basically all it is at this point) will grab all of the
markdown files in the directory it is run in and create a <code>build</code> folder with
the processed output of each one in its corresponding <code>html</code> file. For a pretty
stripped down idea of what a static site generator is, this ~20 line script
basically fits the bill. Pretty neat! This will be the basis for further posts.</p>
<p>Why was this so easy?</p>
<p>I&#39;m using libraries that fit my use case really well. If I had to start from
&quot;write a markdown parser/generator&quot; this would be a longer first post. The fact
that it supports <em>frontmatter</em> even is quite the stroke of luck.</p>
<p>Deno is <em>much more</em> &quot;batteries included&quot; than node ever was. <code>ensureDirSync</code>
and <code>expandGlobSync</code> are just part of the standard library in deno. In node,
the former requires a tiny bit of ceremony, but the latter necessitates a
<a href="https://www.npmjs.com/package/recursive-readdir">whole-ass library</a>. Classic
node.</p>
</div>
      </article>
    </div>

  </body>
</html>
