<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Adventure of Advent of Code</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="http://dev.jfo.click/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta property="og:title" content="Adventure of Advent of Code" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="http:&#x2F;&#x2F;dev.jfo.click/adventure-of-advent-of-code" />
    <meta property="og:image" content="http:&#x2F;&#x2F;dev.jfo.click/desk.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@jeffowler" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="http://dev.jfo.click">archive</a> &mdash;
        <a href="http://dev.jfo.click/feed.xml">feed</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">Adventure of Advent of Code</h1>
        <sub>Dec 04, 2016</sub>
        <p></p>
        <div><p>So there is this thing that <a href="http://was.tl/">Eric Wastl</a> puts together
once a year called the &quot;<a href="http://adventofcode.com/">Advent of Code</a>.&quot; Every day
at 12 am EST a new puzzle is unlocked. It&#39;s fun, you should totally try it!
This is its second year. You can read more about it <a href="http://adventofcode.com/2016/about">here</a>.</p>
<p>The puzzles are all different from each other day to day- and in fact the
puzzle <em>inputs</em> are different from user to user. You could copy someone&#39;s
solution, but you&#39;d still have to run it on your own input data.</p>
<p>I did 6 days last year before getting distracted and falling &quot;behind.&quot; This
year, I&#39;m doing it a little differently, here&#39;s how.</p>
<h2 id="how-i-m-doing-advent-of-code-this-year">How I&#39;m doing Advent of Code this year</h2>
<p>AoC is a really good opportunity for learning things!</p>

<ul>
<li>new problem solving techniques and algorithms</li>
<li>practice ingesting different input data into usable structures and models in different ways</li>
<li>trying out new programming languages and paradigms</li>
<li>seeing how <em>other people solve the same problems</em> in <a href="https://www.reddit.com/r/adventofcode/comments/5g80ck/2016_day_3_solutions/daq7nqd/">creative and clever ways</a>!</li>
<li>competing with the world or your friends or also yourself for solving the problems &quot;best&quot; or &quot;fastest&quot;</li>
</ul>
<p>Last year, I sort of felt like if I couldn&#39;t compete and keep up to get on the
leaderboard, it wasn&#39;t worth doing it. That was wrong, of course! It is easy to
feel like you&#39;ve &quot;fallen behind&quot; though, and doing all the puzzles right when
they are posted at midnight my time for 25 straight days is <em>very difficult</em> to
sustain. So,</p>
<p><strong>Things I DON&#39;T care about this year</strong>:</p>

<ul>
<li><em>Competing</em>. It&#39;s just not going to happen. I&#39;ve done all the problems so far
right at midnight, but I&#39;m going to have to burst that bubble soon, maybe
I&#39;ll do it tonight.</li>
<li><em>Writing clean, maintainable code for all the problems</em>. Sure, that would be nice, but it&#39;s not a priority.</li>
<li><em>Tests</em>. The puzzle is itself a test, after all, and the server knows the
solution, so solve the problem, and you know your program passed its tests!</li>
</ul>
<p>These programs are by definition one offs- there are a lot more things that I
would like to take into consideration if I were writing a &quot;real&quot; program, or a
service or something... input sanitation... edge case checking, stuff like
that. I&#39;m just not going to worry about any of that as long as it works on the
input I was provided.</p>
<p><strong>Things I DO care about this year</strong>:</p>

<ul>
<li><em>Solving all the puzzles, eventually.</em> I think that this is a reasonable
goal. The problems get really difficult later on, so I doubt I&#39;ll be able
to keep doing them all the day they come out, but I&#39;m a lot more confident
this year that I can finish them all, at some point.</li>
<li><em>Learning a lot!</em> Which is really the whole point! I initially thought I
would try to solve everything in Rust, but I threw that idea out the window
within 30 seconds of the first problem being put up because I wanted to do it
as fast as I could.</li>
</ul>
<p>So I&#39;m going to solve the problem in the way I can think of fastest first,
probably in Ruby. Then, if I feel led to, I&#39;m going to solve the problem in the
fastest or most elegant way I can think of later, maybe using Rust (or clean nice
Ruby). So far, this has been a really great way to do these problems! I don&#39;t
know Rust well enough to enjoy both solving the problem and reading docs at the
same time, but I do want to keep learning it. I <em>do</em> know Ruby well enough to
toss off a solution in whatever random way might occur to me, but I don&#39;t have
too much interest in polishing it up once I&#39;ve finished it.</p>
<p>In the past few days, following this process, a neat thing has been happening!</p>
<h2 id="a-neat-thing-that-s-been-happening">A neat thing that&#39;s been happening</h2>
<p>Because I have told myself that the first iteration doesn&#39;t have to look nice,
or be efficient, or really anything at all, I&#39;ve been able to just jump right
in with writing dumpster fire procedural code that still spits out the answer I
want! Look at this hot garbage from <a href="http://adventofcode.com/2016/day/2">day 2 part 2</a>:</p>

<pre><code class="lang-ruby"><span class="hljs-variable">@input</span> = File.open(<span class="hljs-string">&#x27;./inputs/2.txt&#x27;</span>, <span class="hljs-string">&quot;r&quot;</span>).readlines.each {|<span class="hljs-params">l</span>| l.chomp!}.collect! {|<span class="hljs-params">e</span>| e.split(<span class="hljs-string">&#x27;&#x27;</span>)}
<span class="hljs-variable">@keypadtwo</span> = [[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>], [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>]]
<span class="hljs-keyword">def</span> <span class="hljs-title function_">two</span>
    x = <span class="hljs-number">0</span>
    y = <span class="hljs-number">1</span>
    acc = []

    uplock = <span class="hljs-literal">false</span>
    downlock = <span class="hljs-literal">false</span>
    rightlock = <span class="hljs-literal">false</span>
    leftlock = <span class="hljs-literal">true</span>
    <span class="hljs-variable">@input</span>.each <span class="hljs-keyword">do</span> |<span class="hljs-params">elem</span>|
        elem.each <span class="hljs-keyword">do</span> |<span class="hljs-params">e</span>|
            <span class="hljs-keyword">case</span> e
            <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;U&#x27;</span>
                <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> (leftlock |<span class="hljs-params"></span>| rightlock |<span class="hljs-params"></span>| uplock)
                <span class="hljs-keyword">if</span> downlock
                    downlock = <span class="hljs-literal">false</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> &amp;&amp; x == <span class="hljs-number">1</span>
                    uplock = <span class="hljs-literal">true</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                y -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;D&#x27;</span>
                <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> (leftlock |<span class="hljs-params"></span>| rightlock |<span class="hljs-params"></span>| downlock)
                <span class="hljs-keyword">if</span> uplock
                    uplock = <span class="hljs-literal">false</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">if</span> y == <span class="hljs-number">2</span> &amp;&amp; x == <span class="hljs-number">1</span>
                    downlock = <span class="hljs-literal">true</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                y += <span class="hljs-number">1</span>
            <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;R&#x27;</span>
                <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> (uplock |<span class="hljs-params"></span>| downlock |<span class="hljs-params"></span>| rightlock)
                <span class="hljs-keyword">if</span> leftlock
                    leftlock = <span class="hljs-literal">false</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">if</span> y == <span class="hljs-number">1</span> &amp;&amp; x == <span class="hljs-number">2</span>
                    rightlock = <span class="hljs-literal">true</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                x += <span class="hljs-number">1</span>
            <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;L&#x27;</span>
                <span class="hljs-keyword">next</span> <span class="hljs-keyword">if</span> (uplock |<span class="hljs-params"></span>| downlock |<span class="hljs-params"></span>| leftlock)
                <span class="hljs-keyword">if</span> rightlock
                    rightlock = <span class="hljs-literal">false</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                <span class="hljs-keyword">if</span> y == <span class="hljs-number">1</span> &amp;&amp; x == <span class="hljs-number">0</span>
                    leftlock = <span class="hljs-literal">true</span>
                    <span class="hljs-keyword">next</span>
                <span class="hljs-keyword">end</span>
                x -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">end</span>
            x = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x == -<span class="hljs-number">1</span>
            x = <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">3</span>
            y = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> y == -<span class="hljs-number">1</span>
            y = <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> y == <span class="hljs-number">3</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-keyword">if</span> uplock
            acc &lt;&lt; <span class="hljs-number">1</span>
        <span class="hljs-keyword">elsif</span> downlock
            acc &lt;&lt; <span class="hljs-string">&#x27;D&#x27;</span>
        <span class="hljs-keyword">elsif</span> rightlock
            acc &lt;&lt; <span class="hljs-number">9</span>
        <span class="hljs-keyword">elsif</span> leftlock
            acc &lt;&lt; <span class="hljs-number">5</span>
        <span class="hljs-keyword">else</span>
            acc &lt;&lt; <span class="hljs-variable">@keypadtwo</span>[y][x]
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    acc.join
<span class="hljs-keyword">end</span>

p two
</code></pre>
<p>The specifics of this problem are not important right now, and in fact you&#39;d
need to solve the first part to see them on the link above. But, I mean, even
just looking at the shape of that you can tell that it&#39;s some... not very great
or sophisticated code! There is a ton of repetition, the whole boolean &quot;lock&quot;
construct smells dubious... (even if you don&#39;t know what it does!) This is the
kind of code I would have written a few years ago- it fulfills the task,
but boy howdy is it ugly, and has a ton of nooks and crannies in it where a
simple typo could make everything bad in really funny ways.</p>
<p>But! <em>Why</em> it looks like that is what I&#39;m interested in. It&#39;s like a rough
sketch- it&#39;s me thinking about the problem as &quot;<a href="https://www.infoq.com/presentations/Simple-Made-Easy">easily</a>&quot; as I can.
That code might look (and be) &quot;bad&quot; code, but it&#39;s as clear a procedural
representation of the problem as I could come up with in only a couple of
minutes. Once I&#39;ve solved the problem I can be confident that I really do understand
it, and then I can take my time in implementing either an efficient or elegant
solution for teh learns. Ideally both!</p>
<p>Here&#39;s my Rust for that very same problem:</p>

<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::io::prelude::*;
<span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-keyword">use</span> std::collections::HashSet;
<span class="hljs-keyword">use</span> std::iter::FromIterator;


<span class="hljs-keyword">static</span> GRID : [&amp;<span class="hljs-symbol">&#x27;static</span>[<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>]; <span class="hljs-number">5</span>] = [
    &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>],
    &amp;[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],
    &amp;[<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>, <span class="hljs-number">0</span>],
    &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
];

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">allowedarr</span> = [
        (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>),
        (<span class="hljs-number">2</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),
        (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),
        (<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)
    ];
    <span class="hljs-keyword">let</span> <span class="hljs-variable">allowed</span> = HashSet::&lt;_&gt;::<span class="hljs-title function_ invoke__">from_iter</span>(allowedarr.<span class="hljs-title function_ invoke__">iter</span>());

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;../inputs/2.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();
    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s).<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();
    s.<span class="hljs-title function_ invoke__">truncate</span>(len - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-variable">keys</span>: <span class="hljs-type">String</span> = s
        .<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&quot;\n&quot;</span>)
        .<span class="hljs-title function_ invoke__">map</span>(|tokenlist|
            tokenlist.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">fold</span>((<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), |coord, dir| {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">newcoord</span> = <span class="hljs-keyword">match</span> dir {
                    <span class="hljs-string">&#x27;U&#x27;</span> =&gt; (coord.<span class="hljs-number">0</span> - <span class="hljs-number">1</span>, coord.<span class="hljs-number">1</span>),
                    <span class="hljs-string">&#x27;D&#x27;</span> =&gt; (coord.<span class="hljs-number">0</span> + <span class="hljs-number">1</span>, coord.<span class="hljs-number">1</span>),
                    <span class="hljs-string">&#x27;R&#x27;</span> =&gt; (coord.<span class="hljs-number">0</span>, coord.<span class="hljs-number">1</span> + <span class="hljs-number">1</span>),
                    <span class="hljs-string">&#x27;L&#x27;</span> =&gt; (coord.<span class="hljs-number">0</span>, coord.<span class="hljs-number">1</span> - <span class="hljs-number">1</span>),
                    _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Malformed input&quot;</span>)
                };
                <span class="hljs-keyword">if</span> allowed.<span class="hljs-title function_ invoke__">contains</span>(&amp;newcoord) { newcoord } <span class="hljs-keyword">else</span> { coord }
            })
        )
        .<span class="hljs-title function_ invoke__">map</span>(|coord| GRID[coord.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>][coord.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>])
        .<span class="hljs-title function_ invoke__">map</span>(|e| <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{:x}&quot;</span>, e))
        .collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;()
        .<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;&quot;</span>)
        .<span class="hljs-title function_ invoke__">to_uppercase</span>();

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, keys);
}
</code></pre>
<p>So... I don&#39;t really know yet if this is &quot;good Rust&quot; because I don&#39;t know Rust
super well yet, but I can say for certain that it&#39;s much better written than
the first one!It uses a completely different boundary checking method, and is
much more functional. Again,the specifics of the problem are not that important
here, but you can see that my thinking is clearer. Basically it just pulls in
the input and then chains together a lot of functions to turn that input into
the desired answer! Yay functions!</p>
<p>Here&#39;s where something else neat happened.</p>
<h2 id="something-else-neat-that-happened-">Something else neat that happened.</h2>
<p>Take a look at my ruby solution for the
next day&#39;s second problem:</p>

<pre><code class="lang-rb"><span class="hljs-variable">@input</span> = File.open(<span class="hljs-string">&#x27;./inputs/3.txt&#x27;</span>, <span class="hljs-string">&quot;r&quot;</span>)
.readlines
.collect! {|<span class="hljs-params">e</span>|
    e.split(<span class="hljs-string">&#x27; &#x27;</span>)
    .map! {|<span class="hljs-params">e</span>|e.to_i}
}

p (<span class="hljs-number">0</span>..<span class="hljs-number">2</span>).map{|<span class="hljs-params">i</span>|
    <span class="hljs-variable">@input</span>.map {|<span class="hljs-params">e</span>| e[i]}
    .each_slice(<span class="hljs-number">3</span>)
    .to_a}
.flatten(<span class="hljs-number">1</span>)
.select {|<span class="hljs-params">e</span>| e.inject(<span class="hljs-symbol">:+</span>) &gt; e.max * <span class="hljs-number">2</span> }
.count
</code></pre>
<p>It&#39;s functional af! The whole thing is just one chain of methods that spits out
the answer! It reminds me of the
<a href="https://github.com/twitter/scalding">scalding</a> code I&#39;ve written at work to
produce big data jobs. It also looks like (shocker) the Rust code I wrote the
day before. This is a very clear cross pollination of the different things I&#39;m
looking at right now, and that&#39;s really exciting!</p>
<p>I was thinking about going through all these solutions in greater detail- but I
think a much more important take away than my implementations here is just that
AoC provides a <em>ton</em> of opportunities for learning new things, and that if
you&#39;re interested in that, and puzzles, and or programming, then you should
totally give it a try! And you shouldn&#39;t feel bad about what you use or how you
use it, and just have fun solving the puzzles you can solve! And THEN, search
the <a href="https://www.reddit.com/r/adventofcode/">subreddit</a> or talk to other people
doing the challenges and see what they did! It&#39;s really amazing how many
different ways people find to solve these problems!</p>
</div>
      </article>
    </div>

  </body>
</html>
