<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>The Mandelwat Set</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="http://dev.jfo.click/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta property="og:title" content="The Mandelwat Set" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="http:&#x2F;&#x2F;dev.jfo.click/the-mandelwat-set" />
    <meta property="og:image" content="http:&#x2F;&#x2F;dev.jfo.click/desk.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@jeffowler" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="http://dev.jfo.click">archive</a> &mdash;
        <a href="http://dev.jfo.click/feed.xml">feed</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">The Mandelwat Set</h1>
        <sub>Mar 05, 2017</sub>
        <p></p>
        <div><script>
    var randColor = function() {
        return '#'+Math.floor(Math.random()*16777215).toString(16).toUpperCase();
    }
</script>

<p><image src="http://dev.jfo.click/mb/mb01.jpg" /></p>
<p>If you&#39;ve never seen the Mandelbrot set, do me and also yourself a favor and
<a href="https://www.youtube.com/results?search_query=mandelbrot+zoom">watch some amount of time of one or two of these
videos</a> real
quick.</p>
<p>I know, right? <em>What is that thing.</em></p>
<hr>

<p>I wanted to learn about the Mandelbrot set. I thought, that&#39;s a neat thing!
I wonder how I could make one. Turns out it&#39;s not that hard, really, but you
have to understand the math and also what it <em>is</em>, and those things are pretty
hard, at least for me, because I am not great at math even though I love it
and also the Mandlebrot set is a fractal and fractals are <em>bonkers</em>.</p>
<p>I thought, &quot;Hey, I&#39;m a Web Developer<sup>TM</sup> I should use JavaScript for
this because JavaScript is the best lol!&quot; And so here we are.</p>
<p>I&#39;m going to jump right in and try to explain it practically, but if you feel a
little lost or want something reinforced, jump down to the
<a href="#references">references</a> at the bottom for some good resources and videos to
watch!</p>
<p><image src="http://dev.jfo.click/mb/mb02.jpg" /></p>
<p>So before I can draw a Mandlebrot set, I have to have something to draw on! In
html5 land, that thing is a <code>&lt;canvas&gt;</code></p>
<p>That looks like this:</p>
<canvas></canvas>


<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre>
<p>Here, let me put a border on it so you can see where it is:</p>
<canvas style="border: 1px solid black;"></canvas>


<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid black;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre>
<p>By default, the dimensions of a canvas element will be 150 pixels tall by 300
pixels wide. This is a funny size, and I&#39;m not sure why it&#39;s the default, but
in any case you&#39;re almost always going to want to set the width and height
yourself. You can do this with either with CSS, programatically in JS land, or as
attributes directly on the canvas element. Since there are <a href="https://en.wikipedia.org/wiki/Canvas_element#Canvas_element_size_versus_drawing_surface_size">issues with using
CSS for
this</a>,
and because I don&#39;t intend to resize the canvas dynamically in the JS code,
I&#39;ll just set the attributes directly.</p>
<canvas style="border: 1px solid black;" width="200px" height="200px"></canvas>


<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid black;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre>
<p>Now we just need to slap an <code>id</code> in there and we can grab it from the JavaScriptville.</p>

<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ex0&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: 1px solid black;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200px&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre>
<p>That&#39;s it from the HTML side. All the rest of the canvases will look the same
except with incrementing ids!</p>
<p><image src="http://dev.jfo.click/mb/mb03.jpg" /></p>
<p>You can do many wonderful things on a canvas! First you need to grab a
reference to the thing:</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ex1&quot;</span>);
</code></pre>
<p>And then instantiate a <em>context</em> for drawing on it. For now, we&#39;re just going
to stick with a basic <code>CanvasRenderingContext2D</code>, which can be fetched with a
call like this:</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> context = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);
</code></pre>
<p>From there, there are a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">lot of methods you can call on the
context</a>
to affect the canvas itself. In the following example, notice that we access
the canvas&#39;s <code>width</code> and <code>height</code> attributes to know how big a rectangle to
draw! This is a common pattern, and it will be important later on. Right now
I&#39;m just drawing a rectangle to fill the whole canvas though. <a href="https://www.paulirish.com/2009/random-hex-color-code-snippets/">Also I&#39;m using a
random color
function</a> I found for <a href="/how-react-do">another post</a>.
To run this example, press this button labeled &quot;Run&quot;, right here: <span><button id="ex1button1">Run</button></span>.</p>
<canvas id="ex1" style="border: 1px solid black;" width="200px" height="200px"></canvas>



<pre><code class="lang-js">context.<span class="hljs-title function_">beginPath</span>();
context.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
context.<span class="hljs-property">fillStyle</span> = <span class="hljs-title function_">randColor</span>();
context.<span class="hljs-title function_">fill</span>();
</code></pre>
<script>
    (function() {
        var canvasId = "ex1"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        var render1 = function() {
            context.beginPath();
            context.rect(0, 0, canvas.width, canvas.height);
            context.fillStyle = randColor();
            context.fill();
        }
        document.getElementById(canvasId + "button1").onclick = render1;
    })()
</script>

<p>You can also do other things! Like drawing lines: <span><button id="ex2button">Randinavian</button></span></p>
<canvas id="ex2" style="border: 1px solid black;" width="200px" height="200px"></canvas>



<pre><code class="lang-js">context.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">35</span>;
context.<span class="hljs-property">strokeStyle</span> = <span class="hljs-title function_">randColor</span>();

context.<span class="hljs-title function_">beginPath</span>();
context.<span class="hljs-title function_">moveTo</span>(canvas.<span class="hljs-property">width</span>/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
context.<span class="hljs-title function_">lineTo</span>(canvas.<span class="hljs-property">width</span>/<span class="hljs-number">2</span>, canvas.<span class="hljs-property">height</span>);
context.<span class="hljs-title function_">stroke</span>();

context.<span class="hljs-title function_">beginPath</span>();
context.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>, canvas.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>);
context.<span class="hljs-title function_">lineTo</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>);
context.<span class="hljs-title function_">stroke</span>();
</code></pre>
<script>
    (function() {
        var canvasId = "ex2"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        var render = function() {
            context.beginPath();
            context.rect(0, 0, canvas.width, canvas.height);
            context.fillStyle = randColor();
            context.fill();

            var cross = function(size) {
                context.lineWidth = size;
                context.strokeStyle = randColor();
                context.beginPath();
                context.moveTo(canvas.width/2, 0);
                context.lineTo(canvas.width/2, canvas.height);
                context.stroke();

                context.beginPath();
                context.moveTo(0, canvas.height/2);
                context.lineTo(canvas.width, canvas.height/2);
                context.stroke();
            }
            cross(35);
            if (Math.random() > 0.5) {
                cross(20);
            }
        }
        document.getElementById(canvasId + "button").onclick = render;
    })()
</script>

<p>So, let&#39;s look a little closer at those lines.</p>
<canvas id="ex3" style="border: 1px solid black;" width="200px" height="200px"></canvas>


<pre><code class="lang-js">context.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">5</span>;
context.<span class="hljs-property">strokeStyle</span> = <span class="hljs-title function_">randColor</span>();

context.<span class="hljs-title function_">beginPath</span>();
context.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">50</span>, <span class="hljs-number">20</span>);
context.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">120</span>, <span class="hljs-number">150</span>);
context.<span class="hljs-title function_">stroke</span>();
</code></pre>
<script>
    (function() {
        var canvasId = "ex3"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        context.lineWidth = 5;
        context.strokeStyle = randColor();

        context.beginPath();
        context.moveTo(50, 20);
        context.lineTo(120, 150);
        context.stroke();
    })()
</script>

<p>Those numbers that I&#39;m passing to <code>moveTo</code> and <code>lineTo</code> are x and y values,
sort of, but they&#39;re indexed <em>from the upper left corner</em>. if they exceed the
width or height of the canvas, they&#39;ll just go straight off the side!</p>
<canvas id="ex4" style="border: 1px solid black;" width="200px" height="200px"></canvas>


<pre><code class="lang-js">context.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">5</span>;
context.<span class="hljs-property">strokeStyle</span> = <span class="hljs-title function_">randColor</span>();

context.<span class="hljs-title function_">beginPath</span>();
context.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>);
context.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">1200</span>, <span class="hljs-number">1000</span>);
context.<span class="hljs-title function_">stroke</span>();
</code></pre>
<script>
    (function() {
        var canvasId = "ex4"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        context.lineWidth = 5;
        context.strokeStyle = randColor();

        context.beginPath();
        context.moveTo(50, 100);
        context.lineTo(1200, 1000);
        context.stroke();
    })()
</script>

<p>So, clearly, I have to account for the size of the canvas myself- it&#39;s not
really designed to do that for me. Just keep that in mind!</p>
<p><image src="http://dev.jfo.click/mb/mb12.jpg" /></p>
<p>It seems like this is really how you&#39;re supposed to interact with the canvas...
it&#39;s definitely hinted at by the name, you draw strokes and shapes on it to
achieve a final result.</p>
<p>I am interested in a lower lever api than these drawn lines and
shapes, though. How can I achieve granular control over each pixel? We can
interact directly with the pixels in a canvas by using a representation called
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData"><code>ImageData</code></a>.</p>
<p>Calling <code>createImageData(height, width)</code> on a <code>CanvasRenderingContext2d</code> will
return an ImageData object that contains three things:</p>

<pre><code class="lang-js">context.<span class="hljs-title function_">createImageData</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">// ImageData { data: Uint8ClampedArray[400], width: 10, height: 10 }</span>
</code></pre>
<p>There is the <code>width</code> and <code>height</code> that I expected to see. What is the other
thing? It&#39;s just a 1-dimensional array of bytes! 10 x 10 = 100, it seems like a
10 x 10 ImageData should contain 100 items since it represents 100 pixels, but
it contains 400, because each pixel is represented by 4 bytes, one each for
red, green, blue, and alpha (transparency) channels.
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray"><code>Uint8ClampedArray</code></a>
ensures that any value inside of itself is an integer between 0 and 255,
simulating the hard type of a single byte. This is important because javascript
doesn&#39;t otherwise have any sense of integer types, and internally represents
<a href="http://www.2ality.com/2012/04/number-encoding.html">all numerical values as 64 bit floats.</a></p>
<p>You might expect a 2d array here, like this:</p>

<pre><code class="lang-js">[
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p],
    [p, p, p, p, p, p, p, p, p, p]
]
</code></pre>
<p>Where <code>p</code> is a some sort of pixel object that can be address by attribute like:</p>

<pre><code class="lang-js">p.<span class="hljs-property">r</span> = <span class="hljs-number">255</span>;
p.<span class="hljs-property">g</span> = <span class="hljs-number">0</span>;
p.<span class="hljs-property">b</span> = <span class="hljs-number">0</span>;
p.<span class="hljs-property">a</span> = <span class="hljs-number">0</span>;
</code></pre>
<p>But this is lower level than that. It is literally just a one dimensional
array! Let&#39;s play with it though. This example simply fills all the channels
for all the pixels with a random value.  You&#39;ll notice that it looks a little
pastel, since on average there will be some transparency applied to each
pixel. <span><button id="ex5button">RGB Noise</button></span></p>
<canvas id="ex5" style="border: 1px solid black;" width="200px" height="200px"></canvas>


<pre><code class="lang-js"><span class="hljs-keyword">var</span> imageData = context.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; imageData.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) {
    imageData.<span class="hljs-property">data</span>[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">255</span>;
}
context.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//  0, 0 is the offset to start putting the imageDate into the actual canvas. I won&#x27;t use any other values for that in this article..</span>
</code></pre>
<script>
    (function() {
        var canvasId = "ex5"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        var render = function() {

            var imageData = context.createImageData(canvas.width, canvas.height);
            for (var i = 0; i < imageData.data.length; i += 1) {
                imageData.data[i] = Math.random() * 255;
            }
            context.putImageData(imageData, 0, 0);

        }
        document.getElementById(canvasId + "button").onclick = render;
    })()
</script>


<p>Of course, to be useful we need to look at each pixel&#39;s 4 values as a chunk and
change them accordingly. Here&#39;s a simple little for loop that will do that!
This example simply turns every pixel blue with no transparency.
<span>
    <button id="ex6button">blue</button>
    <button id="ex6clear">clear</button>
</span></p>
<canvas id="ex6" style="border: 1px solid black;" width="200px" height="200px"></canvas>



<pre><code class="lang-js"><span class="hljs-keyword">var</span> imageData = context.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; canvas.<span class="hljs-property">width</span> * canvas.<span class="hljs-property">height</span> * <span class="hljs-number">4</span>; i += <span class="hljs-number">4</span>) {
    imageData.<span class="hljs-property">data</span>[i]     = <span class="hljs-number">255</span>;  <span class="hljs-comment">// red channel</span>
    imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// blue channel</span>
    imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// green channel</span>
    imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>;  <span class="hljs-comment">// alpha channel</span>
}
context.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
<script>
    (function() {
        var canvasId = "ex6"
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        var render = function() {

            var imageData = context.createImageData(canvas.width, canvas.height);
            for (var i = 0; i < canvas.width * canvas.height * 4; i += 4) {
                imageData.data[i]     = 0;
                imageData.data[i + 1] = 0;
                imageData.data[i + 2] = 255;
                imageData.data[i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);

        }
        document.getElementById(canvasId + "button").onclick = render;
        document.getElementById(canvasId + "clear").onclick = function(){context.clearRect(0,0,canvas.width,canvas.height)};
    })()
</script>

<blockquote>
<p>Here&#39;s a small exercise I just thought of. How would one make a widget that uses the
ImageData technique above to create a randomly colored background? How about
one that allows user input for the RGBA values? A canvas that maps mouse
position to the color of the canvas and changes it as you move it around?
These are just some ideas. You wouldn&#39;t have to use ImageData exclusively,
of course, there are easier ways to simply change the background color.</p>
</blockquote>
<p><image src="http://dev.jfo.click/mb/mb04.jpg" /></p>
<p>It is a minor inconvenience to have to address the pixel values linearly like
this, what I&#39;d really like to be able to do is address coordinates inside the
canvas. I can remedy this problem with a little bit of math and a helper function!</p>
<p><code>indexToCoord</code> takes an index value and then computes the x and y pixel offsets
for that index in that imageData object. Note that <code>canvas</code> must be in scope
    and a valid canvas for this to work! I will address that more thoroughly
    later.</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> indexToCoord = <span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
    <span class="hljs-comment">// first, we&#x27;ll divide by 4 to get an absolute pixel. This number</span>
    <span class="hljs-comment">// represents the pixel location where 0 is the upper left and the highest</span>
    <span class="hljs-comment">// index is in the lower right.</span>
    index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / <span class="hljs-number">4</span>);

    <span class="hljs-comment">// now we&#x27;ll make a little coordinate object that has two attributes: x and y</span>
    coord =  {
        <span class="hljs-comment">// x is the modulo of the index and the width of the canvas.</span>
        <span class="hljs-attr">x</span>: index % canvas.<span class="hljs-property">width</span>,
        <span class="hljs-comment">// y is the floored index divided by the canvas width.</span>
        <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / canvas.<span class="hljs-property">width</span>)
    }
    <span class="hljs-comment">// returning that coordinate will let us use it later on</span>
    <span class="hljs-keyword">return</span> coord;
}
</code></pre>
<p>So now, let&#39;s say I have a 10x10 canvas. (That&#39;s a very small canvas, but lol I
guess) and I want to address the pixel marked below with an <code>@</code>.</p>

<pre><code>. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . @ . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
</code></pre>
<p>An ImageData object for this size of 10x10 would contain 400 byte values, and
the 4 bytes associated with that pixel would be at indices 132-136. This is
pretty straight forward, but if I put it through the <code>indexToCoord()</code> function,
I get something a little more palatable!</p>

<pre><code>{ x: 3, y: 3 }
</code></pre>
<p>This tells me a lot more about that pixel&#39;s location.</p>
<p>We&#39;re almost there. I want to be able to use coordinates on a coordinate plane,
this is still 0 indexed from the top and left. Also, I want to decouple the
coordinate from the pixels themselves and simply be able to scale it to
whatever range I want. That scaling value is going to be an &quot;r&quot; value.</p>
<p>Let&#39;s say that I want the coordinate plane to go from -2 to 2 on both axes.
(Just, you know, for example.)</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> indexToCoord = <span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
    index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / <span class="hljs-number">4</span>);
    <span class="hljs-keyword">var</span> r = <span class="hljs-number">4</span>;

    coord =  {
        <span class="hljs-attr">x</span>: index % <span class="hljs-number">10</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / <span class="hljs-number">10</span>)
    }

    <span class="hljs-comment">// coord * 4 (which is the distance from -2 to 2) divided by the axis in pixels.</span>
    <span class="hljs-comment">// this gives us a value between 0 and 4 that is equal to the coordinate</span>
    <span class="hljs-comment">// pixel from earlier.</span>
    coord.<span class="hljs-property">x</span> = ((coord.<span class="hljs-property">x</span> * r / canvas.<span class="hljs-property">height</span>) - r/<span class="hljs-number">2</span>);

    <span class="hljs-comment">// the y value needs its sign flipped since the positive side is above the origin.</span>
    coord.<span class="hljs-property">y</span> = ((coord.<span class="hljs-property">y</span> * r / canvas.<span class="hljs-property">width</span>) - r/<span class="hljs-number">2</span>) * -<span class="hljs-number">1</span> ;

    <span class="hljs-keyword">return</span> coord;
}
</code></pre>
<p>Let&#39;s also assume we have a much larger canvas! 10 x 10 is not very
interesting. 200 x 200, as before, gives us an ImageData object that has
160,000 bytes in it! Again, that&#39;s 200 <em> 200 = 40,000 </em> 4 = 160,000. Quite a
lot.</p>
<p>So we have a way to turn an index into a coordinate that can be scaled
according to what you&#39;re trying to see! Given a canvas of 200 x 200, and a
scale of -2 to 2, then, yields something very close to what you&#39;d expect:</p>

<pre><code class="lang-js"><span class="hljs-title function_">indexToCoord</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// { x: -2,    y: 2 }</span>
<span class="hljs-title function_">indexToCoord</span>(<span class="hljs-number">159999</span>); <span class="hljs-comment">// { x: 1.98,  y: -1.98 }</span>
<span class="hljs-title function_">indexToCoord</span>(<span class="hljs-number">132987</span>); <span class="hljs-comment">// { x: -1.08, y: -1.3199999999999998 }</span>
<span class="hljs-title function_">indexToCoord</span>(<span class="hljs-number">54</span>));    <span class="hljs-comment">// { x: -1.74, y: 2 }</span>
</code></pre>
<p>This is just begging to be abstracted, so that&#39;s what I&#39;m going to do.</p>
<p>First, the constructor will take one thing, a string that represents the canvas
id in the dom! It will assign both <code>canvas</code> and <code>context</code> as private variables.
We&#39;re also going to go ahead and allocate an <code>ImageData</code> object for this graph
that we can reuse.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Graph</span>(<span class="hljs-params">canvasId</span>) {
    <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(canvasId);
    <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);
    <span class="hljs-keyword">var</span> imageData = ctx.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
}
</code></pre>
<p>Next we&#39;ll add that <code>indexToCoord</code> method. I&#39;ve put the <code>r</code> value and the
<code>center</code> value as attributes on the object so that I can manipulate them from
outside, and I&#39;ve added an aspect ratio to scale the coordinates correctly in
case the canvas is not 1:1.</p>
<blockquote>
<p>If I were writing a real graphing library or something, I would want that to
be settable as well, but this is a stepping stone to the Mandelbrot
rendering, which will always be 1:1.</p>
</blockquote>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Graph</span>(<span class="hljs-params">canvasId</span>) {
    <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(canvasId);
    <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);
    <span class="hljs-keyword">var</span> imageData = ctx.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
    <span class="hljs-keyword">var</span> aspectRatio = canvas.<span class="hljs-property">height</span> / canvas.<span class="hljs-property">width</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">4</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span> = {
        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
    };

    <span class="hljs-keyword">var</span> indexToCoord = <span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
        index /= <span class="hljs-number">4</span>;
        coord =  {
            <span class="hljs-attr">x</span>: index % canvas.<span class="hljs-property">width</span>,
            <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / canvas.<span class="hljs-property">width</span>)
        }
        coord.<span class="hljs-property">x</span> = (((coord.<span class="hljs-property">x</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / canvas.<span class="hljs-property">width</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / <span class="hljs-number">2</span>) + (<span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span>.<span class="hljs-property">x</span> * aspectRatio)) / aspectRatio;
        coord.<span class="hljs-property">y</span> = ((((coord.<span class="hljs-property">y</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / canvas.<span class="hljs-property">height</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / <span class="hljs-number">2</span>) * -<span class="hljs-number">1</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span>.<span class="hljs-property">y</span>);
        <span class="hljs-keyword">return</span> coord;
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> imageData = context.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; imageData.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) {
            imageData.<span class="hljs-property">data</span>[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">255</span>;
        }
        context.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }
}
</code></pre>
<p>I&#39;ve also added the rgb noise example as the render function for this object.</p>
<p>Now we can interact with a canvas something like this: <span><button id="ex7button">Run</button></span></p>

<pre><code>var graph = new Graph(&quot;canvas-id&quot;)
graph.render()
</code></pre>
<canvas id="ex7" style="border: 1px solid black;" width="200px" height="200px"></canvas>


<script>
    (function() {
        function Graph(canvasId) {
            var canvas = document.getElementById(canvasId);
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(canvas.width, canvas.height);
            var aspectRatio = canvas.height / canvas.width

            this.r = 4
            this.center = {
                x: 0,
                y: 0
            };

            var indexToCoord = function(index) {
                index /= 4;
                coord =  {
                    x: index % canvas.width,
                    y: Math.floor(index / canvas.width)
                }
                coord.x = (((coord.x * this.r / canvas.width) - this.r / 2) + (this.center.x * aspectRatio)) / aspectRatio;
                coord.y = ((((coord.y * this.r / canvas.height) - this.r / 2) * -1) + this.center.y);
                return coord;
            }.bind(this)

            this.render = function() {
                var imageData = context.createImageData(canvas.width, canvas.height);
                for (var i = 0; i < imageData.data.length; i += 1) {
                    imageData.data[i] = Math.random() * 255;
                }
                context.putImageData(imageData, 0, 0);
            }
        }

        var canvasId = "ex7"
        var graph = new Graph(canvasId)
        document.getElementById(canvasId + "button").onclick = function() {graph.render()};
    })()
</script>

<p>Each pixel, now, can be viewed as a single discrete coordinate on a plane that
can be centered anywhere in the two dimensional plane and scaled up or down
depending on what you want to see!</p>
<p><image src="http://dev.jfo.click/mb/mb05.jpg" /></p>
<p>Before packing away this abstraction and explaining sets, I want to add one
more thing. This render function above just randomly sets all the pixel values,
but of course I want more control than that. I will change the <code>render()</code>
method to accept a predicate function, instead:</p>

<pre><code class="lang-js">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">predicate</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; canvas.<span class="hljs-property">width</span> * canvas.<span class="hljs-property">height</span> * <span class="hljs-number">4</span>; i += <span class="hljs-number">4</span>) {
            set = <span class="hljs-title function_">predicate</span>(<span class="hljs-title function_">indexToCoord</span>(i)) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i]     = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">3</span>] = set;
        }
        context.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }
</code></pre>
<p>Now, for every pixel on a given Graph, the predicate is called on it&#39;s
coordinate and returns whether or not it should be filled in with black or not.
The first three values per pixel are RGB values, and the last one is the
<code>alpha</code> channel, which sets the transparency of the pixel. The higher it is,
the more opaque, so by setting it to its maximum value of <code>255</code>, we make the
pixel black.</p>
<p>From now on we&#39;re going to interact with a Graph object for each canvas in the
next section, like this!</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(<span class="hljs-string">&quot;canvasid&quot;</span>)

<span class="hljs-comment">// the below is the default so we don&#x27;t need to do it.</span>
<span class="hljs-comment">// graph.center = { x: 0, y: 0 }</span>

graph.<span class="hljs-property">r</span> = <span class="hljs-number">500</span>; <span class="hljs-comment">// just for starters, sure.</span>

graph.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-comment">// stuff stuff stuff</span>
    <span class="hljs-comment">// return true or return false</span>
})
</code></pre>
<p>Ok let&#39;s play with it!</p>
<script>
    function Graph(canvasId) {
        var canvas = document.getElementById(canvasId);
        var context = canvas.getContext("2d");
        var imageData = context.createImageData(canvas.width, canvas.height);
        var aspectRatio = canvas.height / canvas.width

        this.r = 4
        this.center = {
            x: 0,
            y: 0
        };

        var indexToCoord = function(index) {
            index /= 4;
            coord =  {
                x: index % canvas.width,
                y: Math.floor(index / canvas.width)
            }
            coord.x = (((coord.x * this.r / canvas.width) - this.r / 2) + (this.center.x * aspectRatio)) / aspectRatio;
            coord.y = ((((coord.y * this.r / canvas.height) - this.r / 2) * -1) + this.center.y);
            return coord;
        }.bind(this)

        this.render = function(predicate) {
            for (var i = 0; i < canvas.width * canvas.height * 4; i += 4) {
                set = predicate(indexToCoord(i)) ? 255 : 0;
                imageData.data[i]     = 0;
                imageData.data[i + 1] = 0;
                imageData.data[i + 2] = 0;
                imageData.data[i + 3] = set;
            }
            context.putImageData(imageData, 0, 0);
        }
    }
</script>

<canvas id="ex8" style="border: 1px solid black;" width="200px" height="200px"></canvas>

<script>
    (function() {
        var canvasId = "ex8"
        var graph = new Graph(canvasId)
        graph.r = 500;
        graph.render(function(coord) {
            return (
                coord.x == coord.y
                ||
                coord.x * 2 == coord.y
                ||
                coord.x * 3 == coord.y
                ||
                coord.x * 4 == coord.y
                ||
                coord.x * 5 == coord.y
                ||
                coord.x * 6 == coord.y
                ||
                coord.x * 40 == coord.y
            )
        });
    })()
</script>


<pre><code class="lang-js">graph.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">return</span> (
        coord.<span class="hljs-property">x</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">2</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">3</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">4</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">5</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">6</span> == coord.<span class="hljs-property">y</span>
        ||
        coord.<span class="hljs-property">x</span> * <span class="hljs-number">40</span> == coord.<span class="hljs-property">y</span>
    )
});
</code></pre>
<p>Above we see a predicate function that basically says: &quot;if the current pixel is
on the line described by one of these equations, fill it in. If not, don&#39;t!&quot;</p>
<p>You&#39;ll notice that some of the lines are not totally smooth, and instead are
made up of dots or dashes. What you&#39;re seeing is kind of sort of a version of
the &quot;<a href="https://en.wikipedia.org/wiki/Screen-door_effect">screen door effect</a>&quot;.
For each individual pixel in, say, this equation:</p>

<pre><code>x * 2 = y
</code></pre>
<p>The pixel&#39;s coordinate must match <em>exactly</em> with the output of the equation in
order to qualify and be filled in. This means that when it&#39;s even with a
multiple of the size of the canvas, it&#39;s much more likely to be filled!</p>
<p>If I were building a fully functional graphing library, I would have to deal
with this issue (and many more!). But I&#39;m not, so I won&#39;t! This is adequate for
now. Let&#39;s talk about sets!</p>
<p><image src="http://dev.jfo.click/mb/mb06.jpg" /></p>
<h1 id="sets-wtf-is-a-set">Sets wtf is a set</h1>
<blockquote>
<p>I&#39;m not going to get into set theory because I don&#39;t know really anything
about it, but maybe it&#39;s worth a mention? Wonder what would be a really good
succinct but not wrong explanation of set theory...</p>
</blockquote>
<p>Let&#39;s say a <a href="https://en.wikipedia.org/wiki/Set_(mathematics">set</a>) is pretty
much what you think it is, then. How can we describe a set? We can have a set
that is completely enumerated.</p>

<pre><code>{ 1, 4, 397376, 89, 44 }
</code></pre>
<p>These are just some numbers. They don&#39;t really have anything in common with
each other, I just typed some numbers. And so for any number <code>x</code> that you can
dream up, <code>x</code> will either be in this set, or not.</p>

<pre><code>|-----------------+------------+
| `x`             | Is in set? |
|:---------------:|:----------:|
| 2               | no         |
| 20              | no         |
| 76              | no         |
| 88              | no         |
| 397376          | yes        |
| 100             | no         |
|-----------------+------------+
</code></pre>
<p>Hey actually, JavaScript has a syntax for exactly this!</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([ <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">397376</span>, <span class="hljs-number">89</span>, <span class="hljs-number">44</span> ])
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)      <span class="hljs-comment">// false</span>
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">20</span>)     <span class="hljs-comment">// false</span>
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">76</span>)     <span class="hljs-comment">// false</span>
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">88</span>)     <span class="hljs-comment">// false</span>
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">397376</span>) <span class="hljs-comment">// true</span>
mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">100</span>)    <span class="hljs-comment">// false</span>
</code></pre>
<p>Will this work??</p>
<canvas id="ex9" style="border: 1px solid black;" width="200px" height="200px"></canvas>

<script>
    (function() {
        var canvasId = "ex9"
        var graph = new Graph(canvasId)
        graph.r = 2;

        var mySet = new Set([
            { x:0, y:1},
            { x:1, y:-1}
        ]);

        graph.render(function(coord) {
            if (mySet.has(coord)){
                debugger
            };
            return mySet.has(coord);
        });
    })()
</script>


<pre><code class="lang-js">
graph.<span class="hljs-property">r</span> = <span class="hljs-number">4</span>;

<span class="hljs-keyword">var</span> myset = <span class="hljs-keyword">new</span> <span class="hljs-title function_">set</span>([
    { <span class="hljs-attr">x</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">0</span> },
    { <span class="hljs-attr">x</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">1</span> }
    { <span class="hljs-attr">x</span>:-<span class="hljs-number">1</span>, <span class="hljs-attr">y</span>:-<span class="hljs-number">1</span> }
]);

graph.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">return</span> mySet.<span class="hljs-title function_">has</span>(coord);
});
</code></pre>
<p>Hmm, no it will not. Because of JavaScript&#39;s equality rules, objects are not
compared to each other by value. To whit, these are falsy:</p>

<pre><code class="lang-js">{} == {} <span class="hljs-comment">// false</span>
{} === {} <span class="hljs-comment">// false</span>
{ <span class="hljs-attr">thing</span>: <span class="hljs-number">7</span> } == { <span class="hljs-attr">thing</span>: <span class="hljs-number">7</span> } <span class="hljs-comment">// false</span>
{ <span class="hljs-attr">thing</span>: <span class="hljs-number">7</span> } === { <span class="hljs-attr">thing</span>: <span class="hljs-number">7</span> } <span class="hljs-comment">// false</span>
<span class="hljs-comment">// etc...</span>
</code></pre>
<p>Objects instead are equal if they are <em>actually the same object</em>, meaning the
two sides of the double or triple equals refer to the same memory.</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> thing1 = { <span class="hljs-attr">whatever</span>: <span class="hljs-string">&quot;whatevar&quot;</span> };
thing1 == thing1 <span class="hljs-comment">// true</span>
thing1 === thing1 <span class="hljs-comment">// true</span>

<span class="hljs-keyword">var</span> thing2 = thing1;

thing1 == thing2 <span class="hljs-comment">// true</span>
thing1 === thing2 <span class="hljs-comment">// true</span>
</code></pre>
<p>You get the idea. Now, I <em>could</em> write a deep checking set class for these
coordinates, or build the coordinates into a real object that has a function
that can do that, but I don&#39;t really want to. Instead I&#39;m going to talk
about sets more generally!</p>
<p><image src="http://dev.jfo.click/mb/mb13.jpg" /></p>
<p>So, you can have a set that is just a defined set of whatever, and write all
the whatevers out, like the example above.. That works great! But what about
something like this:</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> mySet = { <span class="hljs-comment">/* The set of all even integers */</span> }
</code></pre>
<p>Obviously, I can&#39;t write that out! But I <em>can</em> check if an arbitrary number is
a member of that set with a simple function.</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> isInTheSetOfAllEvenIntegers = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
}
</code></pre>
<p>Hey cool! This is like, a programaticalized way to test for set membership in
that particular set of numbers.</p>
<canvas id="ex10" style="border: 1px solid black;" width="200px" height="200px"></canvas>

<script>
    (function() {
        var canvasId = "ex10"
        var graph = new Graph(canvasId)
        graph.r = 20;

        graph.render(function(coord) {
            return coord.x % 2 == 0;
        });
    })()
</script>


<pre><code class="lang-js"><span class="hljs-comment">// we&#x27;re making the scale of the graph 20x20 here</span>
graph.<span class="hljs-property">r</span> = <span class="hljs-number">20</span>;

graph.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">return</span> coord.<span class="hljs-property">x</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
});
</code></pre>
<p>Now we&#39;re getting somewhere! What about this one:</p>

<pre><code>The set of all points whose x value is higher than 100 and whose y value is higher that -27;
</code></pre>
<canvas id="ex11" style="border: 1px solid black;" width="200px" height="200px"></canvas>

<script>
    (function() {
        var canvasId = "ex11"
        var graph = new Graph(canvasId)
        graph.r = 500;

        graph.render(function(coord) {
            return (coord.x > 100 && coord.y > -27);
        });
    })()
</script>


<pre><code class="lang-js"><span class="hljs-comment">// again, changing the scale of the graph.</span>
graph.<span class="hljs-property">r</span> = <span class="hljs-number">500</span>;

graph.<span class="hljs-title function_">render</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">return</span> (coord.<span class="hljs-property">x</span> &gt; <span class="hljs-number">100</span> &amp;&amp; coord.<span class="hljs-property">y</span> &gt; -<span class="hljs-number">27</span>);
});
</code></pre>
<p>This is cool, then, I have a way of &quot;graphing&quot; sets! These sets are pretty
boring though. But you know what&#39;s not boring??</p>
<p><image src="http://dev.jfo.click/mb/mb07.jpg" /></p>
<h1 id="the-mandelbrot-set">The Mandelbrot Set</h1>
<p>Ok, The Mandelbrot set is:</p>
<blockquote>
<p>The set of all complex numbers that remain bounded when iterated on the equation f<sub>c</sub>(z) = z<sup>2</sup> + c</p>
</blockquote>
<p>Ok so real talk, there are like 3 or 4 things in that definition that I totally
did not understand at all when I started this project. But I do now, and I&#39;m
going to explain them to you, one by one!</p>
<p>Let&#39;s start with the equation.</p>
<blockquote>
<p>f<sub>c</sub>(z) = z<sup>2</sup> + c</p>
</blockquote>
<p>This part&#39;s pretty easy. I have a function, and I feed it a number, and I get a number back.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">z</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(z, <span class="hljs-number">2</span>) + c;
}
</code></pre>
<p>This is, of course, borked.</p>

<pre><code class="lang-js"><span class="hljs-title function_">thinger</span>(<span class="hljs-number">2</span>);
</code></pre>

<pre><code>ReferenceError: c is not defined
    at thinger (/private/tmp/thinger.js:2:29)
    at Object.&lt;anonymous&gt; (/private/tmp/thinger.js:5:13)
    at Module._compile (module.js:570:32)
    at Object.Module._extensions..js (module.js:579:10)
    at Module.load (module.js:487:32)
    at tryModuleLoad (module.js:446:12)
    at Function.Module._load (module.js:438:3)
    at Module.runMain (module.js:604:10)
    at run (bootstrap_node.js:394:7)
    at startup (bootstrap_node.js:149:9)
</code></pre>
<p><code>c</code> here must be defined. I will define it then!</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">z, c</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(z, <span class="hljs-number">2</span>) + c;
}
</code></pre>
<p>Cool cool. I can plug whatever in there now great.</p>

<pre><code class="lang-js"><span class="hljs-title function_">thinger</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);
<span class="hljs-title function_">thinger</span>(<span class="hljs-number">40</span>, <span class="hljs-number">3</span>);
<span class="hljs-title function_">thinger</span>(<span class="hljs-number">4000</span>, <span class="hljs-number">3.32</span>);
</code></pre>

<pre><code>18
1603
16000003.32
</code></pre>
<p>Ok so now, what does &#39;iterated on&#39; mean?</p>
<p>It means that I take the output of the function and feed it back into the same
function. The initial <code>z</code> input is always 0.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">z, c</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(z, <span class="hljs-number">2</span>) + c, c);
}
</code></pre>
<p>Obviously, this is also borked.</p>

<pre><code>RangeError: Maximum call stack size exceeded
    at Object.pow (native)
    ...
</code></pre>
<p>This is a recursive function with no base case. This is where the &quot;bounded&quot;
part comes in. For a given input, this equation exhibits one of two behaviors
under iteration. It can either stay <em>bounded</em> Or it can <em>explode</em> to infinity.
This makes a little more sense if we see some output. I&#39;ll add a counter that
I&#39;ll increment on each call just to give us a way to get out of the recursive
loop.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">z, c, i</span>) {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> next = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(z, <span class="hljs-number">2</span>) + c;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(next);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">thinger</span>(next, c, i += <span class="hljs-number">1</span>);
}
</code></pre>
<p>Now, we can see some interesting stuff.</p>

<pre><code class="lang-js"><span class="hljs-title function_">thinger</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
</code></pre>

<pre><code>2
6
38
1446
2090918
4371938082726
1.9113842599189892e+25
3.653389789066062e+50
1.3347256950852164e+101
1.781492681120714e+202
Infinity
</code></pre>
<p>Exponents are no joke, and 2 decidedly does <em>not</em> remain bounded.</p>
<p>What about this one?</p>

<pre><code class="lang-js"><span class="hljs-title function_">thinger</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
</code></pre>
<p>Hmm...</p>

<pre><code>-1
0
-1
0
-1
0
-1
0
-1
0
-1
</code></pre>
<p><em>But this one does!</em> -1 is thus <em>in the Mandelbrot set</em>, and 2 <em>is not</em>.</p>
<p><image src="http://dev.jfo.click/mb/mb08.jpg" /></p>
<p>Wait, though, we were talking about <em>complex numbers</em>. And the numbers -1 and 2
are not coordinates, they are integers. How do you make a 2 dimensional graph
with one number?</p>
<p>These two questions answer each other!</p>
<p>The Mandelbrot set is not plotted on a <a href="http://dl.uncw.edu/digilib/mathematics/algebra/mat111hb/functions/coordinates/coordinates.html">Cartesian
plane</a>,
where each point is represented as a pair of numbers <code>&lt;x, y&gt;</code>. It&#39;s plotted on
the <a href="https://en.wikipedia.org/wiki/Complex_plane"><em>complex plane</em></a>. Where each
point is represented by a single <em>complex number.</em></p>
<p>A <em>complex number</em> is an expression of the form <code>x + yi</code> where <code>x</code> and <code>y</code> are
<a href="https://en.wikipedia.org/wiki/Real_number">real numbers</a> and <code>i</code> is the <a href="https://en.wikipedia.org/wiki/Imaginary_number"><em>unit
imaginary number</em></a>. Though <code>y</code> alone
is a real number, it is here the coefficient of <code>i</code>, and so cannot be combined
with <code>x</code>. On the complex plane, we plot <code>x</code> (the &quot;real&quot; part of the complex
number) on the x axis and <code>y</code> (the &quot;imaginary&quot; part of the complex number) on
the y axis. This took me a while to understand but it&#39;s pretty simple really!
<a href="https://www.khanacademy.org/math/algebra2/introduction-to-complex-numbers-algebra-2/the-complex-numbers-algebra-2/v/complex-number-intro">Here&#39;s a Khan Academy
video</a>
that explains it in more detail.</p>
<p>So the cartesian coordinate <code>(1, 2)</code> would be represented on the complex plane as the
complex number <code>1 + 2i</code>.</p>
<p>So, remember, we wanted to feed <em>complex numbers</em> into that function, but we
can&#39;t because javascript doesn&#39;t have a <em>complex number</em> type. There are, of
course, <a href="https://www.npmjs.com/search?q=complex%20number&amp;page=2&amp;ranking=optimal">36 packages on npm that probably can do
this</a>,
but I&#39;m not going to use any of them, because reasons!</p>
<p>No but seriously. It&#39;s just one application and I can do it by hand and that&#39;s
how we learn new things.</p>
<p><image src="http://dev.jfo.click/mb/mb09.jpg" /></p>
<p>So, A complex number is made up of a real part and an imaginary part. Never the
two shall meet. What if I wanted to add two complex numbers together?</p>

<pre><code>(1 + 2i) + (3 + 5i) = 4 + 7i
</code></pre>
<p>Alright. But in JS, I could just keep track of these two parts <em>separately.</em></p>

<pre><code class="lang-js">realOne = <span class="hljs-number">1</span>;
imaginaryOne = <span class="hljs-number">2</span>;
realTwo = <span class="hljs-number">3</span>;
imaginaryTwo = <span class="hljs-number">5</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([realOne + realTwo, imaginaryOne + imaginaryTwo]
</code></pre>

<pre><code>[4, 7]
</code></pre>
<p>Or <code>4 + 7i</code>.</p>
<p>I&#39;m returning this as a tuple of two values. I could use objects, if I wanted...</p>

<pre><code class="lang-js">first = {
    <span class="hljs-attr">real</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">imaginary</span>: <span class="hljs-number">2</span>
};
second = {
    <span class="hljs-attr">real</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">imaginary</span>: <span class="hljs-number">5</span>
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>({
    <span class="hljs-attr">real</span>: first.<span class="hljs-property">real</span> + second.<span class="hljs-property">real</span>,
    <span class="hljs-attr">imaginary</span>: first.<span class="hljs-property">imaginary</span> + second.<span class="hljs-property">imaginary</span>
});
</code></pre>

<pre><code class="lang-js">{ <span class="hljs-attr">real</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">imaginary</span>: <span class="hljs-number">7</span> }
</code></pre>
<p>Do you see it? Do you see how this is just <em>dying</em> to be made into a prototype
that implements basic math over itself and stuff? Oh man, it really wants me to
do that, but I&#39;m not going to do it.</p>
<p>We also need to be able to <em>multiply</em> complex numbers, in order to square them.
What does that look like? It looks like algebra. Remember <code>FOIL</code>? &quot;First,
outer, inner, last.&quot;</p>
<blockquote>
<p>(1 + 2i) * (3 + 5i)</p>
<p>(1 <em> 3) + (1 </em> 5i) + (2i <em> 3) + (2i </em> 5i)</p>
<p>3 + 5i + 6i + 10i<sup>2</sup></p>
<p>3 + 11i + 10i<sup>2</sup></p>
<p>3 + 11i + 10(i * i)</p>
<p>3 + 11i + 10(-1)</p>
<p>3 + 11i - 10</p>
<p>-7 + 11i</p>
</blockquote>
<p>Remember that <code>i</code> is actually the square root of -1, so i<sup>2</sup> is...
<code>-1</code>!</p>
<p><image src="http://dev.jfo.click/mb/mb13.jpg" /></p>
<p>So... let&#39;s go back to our testing function from before! All I need to do is
replace <code>z</code> and <code>c</code> with &quot;complex numbers&quot; made up of <code>zr</code> (z real), <code>zi</code> (z
imaginary), <code>cr</code> (c real), and <code>ci</code> (c imaginary). I&#39;ll keep that index var <code>i</code> around
for now, as well, but I&#39;m going to change it to <code>iterations</code> for a little more clarity.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">zr, zi, cr, ci, iterations</span>) {
    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">10</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> nextr = (zr * zr) - (zi * zi) + cr;
    <span class="hljs-keyword">var</span> nexti = ((zr * zi) *<span class="hljs-number">2</span>) + ci

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([nextr, nexti]);

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">thinger</span>(nextr, nexti, cr, ci, iterations += <span class="hljs-number">1</span>);
}
</code></pre>
<p>Those <code>nextr</code> and <code>nexti</code> expressions are just what you get when you factor out
the real and imaginary operations from the <code>FOIL</code> procedure from above.</p>
<p>So here&#39;s the trick. Right now I&#39;m sort of just, winging it with those
iteration counts. But how do I <em>really</em> know if a point is not in the set?</p>
<blockquote>
<p>If the sum of the squares of the real and imaginary parts of the complex
number <em>ever exceed 4</em>, then that complex number is <em>not</em> in the Mandelbrot
set.</p>
</blockquote>
<p>That&#39;s a little more useful!</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thinger</span>(<span class="hljs-params">zr, zi, cr, ci, iterations</span>) {
    <span class="hljs-keyword">if</span> (iterations &gt; <span class="hljs-number">20</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> nextr = (zr * zr) - (zi * zi) + cr;
    <span class="hljs-keyword">var</span> nexti = ((zr * zi) *<span class="hljs-number">2</span>) + ci
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([nextr, nexti]);

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(nextr, <span class="hljs-number">2</span>) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(nexti, <span class="hljs-number">2</span>) &gt; <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">thinger</span>(nextr, nexti, cr, ci, iterations += <span class="hljs-number">1</span>);
}
</code></pre>
<p>So what we have here... this is getting there. If the condition stated above is
met, then the number is not in the set. BUT if we&#39;ve reached some maximum
iteration count, then <em>as far as we know</em>, the number <em>is</em> in the set. That&#39;s
going to be important later on!</p>
<p>It&#39;s cute to have this be recursive and all, but it&#39;s unnecessary. The formula
looks cleaner as a loop and is less computationally expensive. We can let that
state be internal and leave it out of the function signature. And as a matter
of fact, dropping the recursion means we don&#39;t have to pass in the inital <code>zr</code>
and <code>zi</code>, either. And what the hell, why don&#39;t I change that name from
<code>thinger</code> to something a little more descriptive...</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMandlebrot</span>(<span class="hljs-params">cr, ci</span>) {
    <span class="hljs-keyword">var</span> zr = cr;
    <span class="hljs-keyword">var</span> zi = ci

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
        <span class="hljs-keyword">if</span> (zr**<span class="hljs-number">2</span> + zi**<span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        newzr = (zr * zr) - (zi * zi) + cr;
        newzi = ((zr * zi) *<span class="hljs-number">2</span>) + ci;
        zr = newzr;
        zi = newzi;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>Ok so, remember those predicate functions from before? They took in a <code>coord</code>
with an <code>x</code> value and a <code>y</code> value? Doesn&#39;t that look... suspiciously similar to
what we&#39;ve got above?</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMandlebrot</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">var</span> cr = coord.<span class="hljs-property">x</span>;
    <span class="hljs-keyword">var</span> ci = coord.<span class="hljs-property">y</span>;
    <span class="hljs-keyword">var</span> zr = cr;
    <span class="hljs-keyword">var</span> zi = ci;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
        <span class="hljs-keyword">if</span> (zr**<span class="hljs-number">2</span> + zi**<span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        newzr = (zr * zr) - (zi * zi) + cr;
        newzi = ((zr * zi) *<span class="hljs-number">2</span>) + ci;
        zr = newzr;
        zi = newzi;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<canvas id="ex12" height="200" width="200" style="border: 1px solid black;"></canvas>

<script>
(function() {
    function isMandlebrot(coord) {
        var cr = coord.x;
        var ci = coord.y;
        var zr = cr;
        var zi = ci;

        for (var i = 0; i < 100; i++) {
            if (zr**2 + zi**2 > 4) {
                return false;
            }

            newzr = (zr * zr) - (zi * zi) + cr;
            newzi = ((zr * zi) *2) + ci;
            zr = newzr;
            zi = newzi;
        }
        return true;
    }

    var graph = new Graph("ex12");
    graph.render(isMandlebrot);
})();
</script>


<pre><code class="lang-js"><span class="hljs-keyword">var</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Graph</span>(<span class="hljs-string">&quot;ex12&quot;</span>);
graph.<span class="hljs-title function_">render</span>(isMandlebrot);
</code></pre>
<p>There it is. Our old friend. The Mandelbrot set.</p>
<p><image src="http://dev.jfo.click/mb/mb44.jpg" /></p>
<h1 id="that-looks-like-a-fuzzy-potato">That looks like a fuzzy potato</h1>
<p>Yeah, it might look boring from where we&#39;re sitting, <em>but it&#39;s totally not</em></p>
<p>Remember when I built that &quot;Graph&quot; object, I made both <code>r</code> (the zoom factor)
and <code>center</code> accessible. We can totally change where we&#39;re looking at the graph
and re-render on the fly!</p>
<canvas id="ex13" height="200" width="200" style="border: 1px solid black;"></canvas>

<button class="ex13button" data-centerx="-0.7463" data-centery="0.1102" data-r="0.005" >x:-0.7463, y:0.1102, r:0.005</button>
<button class="ex13button" data-centerx="-0.7453" data-centery="0.1127" data-r="0.00065" >x:-0.7453, y:0.1127, r:0.00065</button>
<button class="ex13button" data-centerx="-1.25066" data-centery="0.02012" data-r="0.0005" >x:-1.25066, y:0.02012, r:0.0005</button>
<button class="ex13button" data-centerx="-0.16" data-centery="1.0405" data-r="0.076">x:-0.16, y:1.0405 r:0.046</button>

<script>
(function() {
    function isMandlebrot(coord) {
        var cr = coord.x;
        var ci = coord.y;
        var zr = cr;
        var zi = ci;

        for (var i = 0; i < 100; i++) {
            if (zr**2 + zi**2 > 4) {
                return false;
            }

            newzr = (zr * zr) - (zi * zi) + cr;
            newzi = ((zr * zi) *2) + ci;
            zr = newzr;
            zi = newzi;
        }
        return true;
    }
    var canvasId = "ex13";
    var graph = new Graph(canvasId);
    graph.render(isMandlebrot);

    var buttons =  document.getElementsByClassName(canvasId + "button");
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].onclick = function(e) {
            graph.center = {
                x: parseFloat(e.currentTarget.getAttribute('data-centerx')),
                y: parseFloat(e.currentTarget.getAttribute('data-centery'))
            };
            graph.r = parseFloat(e.currentTarget.getAttribute('data-r'))
            graph.render(isMandlebrot);
        };
    };

})();
</script>


<h1 id="small-refactor">Small refactor</h1>
<p>So at this point I am going to drop the more general <code>Graph</code> abstraction and
just hardcode that object&#39;s predicate as the Mandelbrot test. That... pretty
much looks like you would expect.</p>

<pre><code class="lang-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Mandelbrot</span>(<span class="hljs-params">canvasId</span>) {
    <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(canvasId);
    <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);
    <span class="hljs-keyword">var</span> imageData = ctx.<span class="hljs-title function_">createImageData</span>(canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);
    <span class="hljs-keyword">var</span> aspectRatio = canvas.<span class="hljs-property">height</span> / canvas.<span class="hljs-property">width</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterations</span> = <span class="hljs-number">200</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">4</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span> = {
        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
    };

    <span class="hljs-keyword">var</span> indexToCoord = <span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
        index /= <span class="hljs-number">4</span>;
        coord =  {
            <span class="hljs-attr">x</span>: index % canvas.<span class="hljs-property">width</span>,
            <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(index / canvas.<span class="hljs-property">width</span>)
        }
        coord.<span class="hljs-property">x</span> = (((coord.<span class="hljs-property">x</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / canvas.<span class="hljs-property">width</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / <span class="hljs-number">2</span>) + (<span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span>.<span class="hljs-property">x</span> * aspectRatio)) / aspectRatio;
        coord.<span class="hljs-property">y</span> = ((((coord.<span class="hljs-property">y</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / canvas.<span class="hljs-property">height</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> / <span class="hljs-number">2</span>) * -<span class="hljs-number">1</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span>.<span class="hljs-property">y</span>);
        <span class="hljs-keyword">return</span> coord;
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)

    <span class="hljs-keyword">var</span> isMandlebrot = <span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
        <span class="hljs-keyword">var</span> cr = coord.<span class="hljs-property">x</span>
        <span class="hljs-keyword">var</span> ci = coord.<span class="hljs-property">y</span>
        <span class="hljs-keyword">var</span> zr = coord.<span class="hljs-property">x</span>
        <span class="hljs-keyword">var</span> zi = coord.<span class="hljs-property">y</span>

        <span class="hljs-keyword">var</span> i;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterations</span>; i++) {
            <span class="hljs-keyword">if</span> (zr**<span class="hljs-number">2</span> + zi**<span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            newzr = (zr * zr) - (zi * zi) + cr;
            newzi = ((zr * zi) *<span class="hljs-number">2</span>) + ci
            zr = newzr
            zi = newzi
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">predicate</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; canvas.<span class="hljs-property">width</span> * canvas.<span class="hljs-property">height</span> * <span class="hljs-number">4</span>; i += <span class="hljs-number">4</span>) {
            set = <span class="hljs-title function_">predicate</span>(<span class="hljs-title function_">indexToCoord</span>(i)) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i]     = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">3</span>] = set;
        }
        ctx.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)
}
</code></pre>
<script>
function MandelbrotOne(canvasId) {
    var canvas = document.getElementById(canvasId);
    var ctx = canvas.getContext("2d");
    var imageData = ctx.createImageData(canvas.width, canvas.height);
    var aspectRatio = canvas.height / canvas.width

    this.iterations = 200;
    this.r = 4
    this.center = {
        x: 0,
        y: 0
    };

    var indexToCoord = function(index) {
        index /= 4;
        coord =  {
            x: index % canvas.width,
            y: Math.floor(index / canvas.width)
        }
        coord.x = (((coord.x * this.r / canvas.width) - this.r / 2) + (this.center.x * aspectRatio)) / aspectRatio;
        coord.y = ((((coord.y * this.r / canvas.height) - this.r / 2) * -1) + this.center.y);
        return coord;
    }.bind(this)

    var isMandlebrot = function(coord) {
        var cr = coord.x
        var ci = coord.y
        var zr = coord.x
        var zi = coord.y

        var i;
        for (i = 0; i < this.iterations; i++) {
            if (zr**2 + zi**2 > 4) {
                return false;
            }

            newzr = (zr * zr) - (zi * zi) + cr;
            newzi = ((zr * zi) *2) + ci
            zr = newzr
            zi = newzi
        }
        return true;
    }.bind(this);

    this.render = function() {
        for (var i = 0; i < canvas.width * canvas.height * 4; i += 4) {
            set = isMandlebrot(indexToCoord(i)) ? 255 : 0;
            imageData.data[i]     = 0;
            imageData.data[i + 1] = 0;
            imageData.data[i + 2] = 0;
            imageData.data[i + 3] = set;
        }
        ctx.putImageData(imageData, 0, 0);
    }.bind(this)
}
</script>

<canvas id="ex14" height="200" width="200" style="border: 1px solid black;"></canvas>

<script>
    var mb = new MandelbrotOne("ex14")
    mb.render();
</script>

<p>Now, I can do something like this:</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> mb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mandelbrot</span>(<span class="hljs-string">&quot;ex14&quot;</span>)
mb.<span class="hljs-title function_">render</span>();
</code></pre>
<p>There&#39;s one important change here! In the <code>Mandelbrot</code> object above, you can
see that I&#39;ve exposed another attribute. <code>this.iterations</code>, and used it as a
maximum value in the for loop in the Mandelbrot function.</p>
<p>Why are iterations important? Well, the more iterations we use the more fine
grained the Mandlebrot can be displayed. Look at this!</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> mb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MandelbrotOne</span>(<span class="hljs-string">&quot;ex15&quot;</span>)
<span class="hljs-keyword">var</span> iterations = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    mb.<span class="hljs-property">iterations</span> = iterations += x
    <span class="hljs-keyword">if</span> (iterations == <span class="hljs-number">20</span>) {
        x = -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iterations == <span class="hljs-number">0</span>) {
        x = <span class="hljs-number">1</span>;
    }
    mb.<span class="hljs-title function_">render</span>();
}, <span class="hljs-number">1000</span>)
</code></pre>
<canvas id="ex15" height="200" width="200" style="border: 1px solid black;"></canvas>

<script>
(function() {
    var mb = new MandelbrotOne("ex15")
    var iterations = 1;
    var x = 1;
    setInterval(function(){
        mb.iterations = iterations += x
        if (iterations == 20) {
            x = -1;
        } else if (iterations == 0) {
            x = 1;
        }
        mb.render();
    }, 200)
})()
</script>

<p>As the iterations cycle back and forth, you can see that the edges of the set
get more definition. That could go on infinitely, though what you see above is
about as high fidelity as we can get at that zoom level, since pixels have a
definite size, small as they may seem.</p>
<p><image src="http://dev.jfo.click/mb/mb10.jpg" /></p>
<h1 id="colors-come-out-of-the-speakers">Colors come out of the speakers</h1>
<p>Let&#39;s talk about those trippy ass colors you see on all the zooms on youtube.</p>
<p>Right now we&#39;ve got a pretty simple true false test that tells us if a pixel is
not in the set or if, <em>as far as we know</em>, it is. Every extra iteration increases
the fidelity of that second category, as you can see in the doodad above. The
thing is, we&#39;re throwing away some information here We&#39;re throwing away <em>how
many iterations it took us</em> to figure out that a point was not in the set. This
is really interesting information!</p>
<p>Currently, the render function uses the boolean value returned by
<code>isMandlebrot</code> to decide whether or not to set the <code>opacity</code> &#39;byte&#39; to either
255, or 0.</p>

<pre><code class="lang-js">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; canvas.<span class="hljs-property">width</span> * canvas.<span class="hljs-property">height</span> * <span class="hljs-number">4</span>; i += <span class="hljs-number">4</span>) {
            set = <span class="hljs-title function_">isMandlebrot</span>(<span class="hljs-title function_">indexToCoord</span>(i)) ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i]     = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
            imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">3</span>] = set;
        }
        ctx.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)
</code></pre>
<p>We can change <code>isMandlebrot</code> to return a tuple instead, of two things: the
original boolean value <em>and the iterations required to divine it</em>.</p>

<pre><code class="lang-js"><span class="hljs-keyword">var</span> isMandlebrot = <span class="hljs-keyword">function</span>(<span class="hljs-params">coord</span>) {
    <span class="hljs-keyword">var</span> cr = coord.<span class="hljs-property">x</span>
    <span class="hljs-keyword">var</span> ci = coord.<span class="hljs-property">y</span>
    <span class="hljs-keyword">var</span> zr = coord.<span class="hljs-property">x</span>
    <span class="hljs-keyword">var</span> zi = coord.<span class="hljs-property">y</span>

    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterations</span>; i++) {
        <span class="hljs-keyword">if</span> (zr**<span class="hljs-number">2</span> + zi**<span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>) {
            <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, i];
        }

        newzr = (zr * zr) - (zi * zi) + cr;
        newzi = ((zr * zi) *<span class="hljs-number">2</span>) + ci
        zr = newzr
        zi = newzi
    }
    <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, i];
}.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre>
<p>Now, back in the render function, we can use that information to color the
pixel according to it&#39;s iteration score!</p>

<pre><code class="lang-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; canvas.<span class="hljs-property">width</span> * canvas.<span class="hljs-property">height</span> * <span class="hljs-number">4</span>; i += <span class="hljs-number">4</span>) {
        thing = <span class="hljs-title function_">isMandlebrot</span>(<span class="hljs-title function_">indexToCoord</span>(i))
        set =  thing[<span class="hljs-number">0</span>] ?  <span class="hljs-number">0</span>: (thing[<span class="hljs-number">1</span>] / <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterations</span>) * <span class="hljs-number">0xffffff</span>;
        imageData.<span class="hljs-property">data</span>[i]     = (set &amp; <span class="hljs-number">0xff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;
        imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">1</span>] = (set &amp; <span class="hljs-number">0x00ff00</span>) &gt;&gt; <span class="hljs-number">8</span>;
        imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">2</span>] = set &amp; <span class="hljs-number">0x0000ff</span>;
        imageData.<span class="hljs-property">data</span>[i + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>;
    }
    ctx.<span class="hljs-title function_">putImageData</span>(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)
</code></pre>
<blockquote>
<p><code>set</code> here is a value that I&#39;m first normalizing between 0 and 1, then
scaling to be between 0 and 16777215. Then I&#39;m extracting RGB values in kind
from it with some bit twiddling. Sorry I&#39;m not explaining that more/better,
I&#39;m turning the iteration count into a color value is all!</p>
</blockquote>
<p>This is <em>drastically</em> cooler looking.</p>
<script>
    function Mandelbrot(canvasId) {
        var canvas = document.getElementById(canvasId);
        var ctx = canvas.getContext("2d");
        var imageData = ctx.createImageData(canvas.width, canvas.height);
        var aspectRatio = canvas.height / canvas.width

        this.iterations = 200;
        this.r = 4
        this.center = {
            x: 0,
            y: 0
        };

        var indexToCoord = function(index) {
            index /= 4;
            coord =  {
                x: index % canvas.width,
                y: Math.floor(index / canvas.width)
            }
            coord.x = (((coord.x * this.r / canvas.width) - this.r / 2) + (this.center.x * aspectRatio)) / aspectRatio;
            coord.y = ((((coord.y * this.r / canvas.height) - this.r / 2) * -1) + this.center.y);
            return coord;
        }.bind(this)

        var isMandlebrot = function(coord) {
            var cr = coord.x
            var ci = coord.y
            var zr = coord.x
            var zi = coord.y

            var i;
            for (i = 0; i < this.iterations; i++) {
                if (zr**2 + zi**2 > 4) {
                    return [false, i];
                }

                newzr = (zr * zr) - (zi * zi) + cr;
                newzi = ((zr * zi) *2) + ci
                zr = newzr
                zi = newzi
            }
            return [true, i];
        }.bind(this);

        this.render = function() {
            for (var i = 0; i < canvas.width * canvas.height * 4; i += 4) {
                thing = isMandlebrot(indexToCoord(i))
                set =  thing[0] ? 0 : (thing[1] / this.iterations) * 0xffffff;
                imageData.data[i]     = (set & 0xff0000) >> 16;
                imageData.data[i + 1] = (set & 0x00ff00) >> 8;
                imageData.data[i + 2] = set & 0x0000ff;
                imageData.data[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
        }.bind(this)
    }
</script>

<canvas id="ex16" height="200" width="200" style="border: 1px solid black;"></canvas>

<script>
(function() {
    var mb = new Mandelbrot("ex16")
    mb.render();
})()
</script>


<pre><code class="lang-js"><span class="hljs-keyword">var</span> mb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mandelbrot</span>(<span class="hljs-string">&quot;ex16&quot;</span>)
mb.<span class="hljs-title function_">render</span>();
</code></pre>
<p>Remember those little thingers from before? Look what they look like in <em>color</em>!!</p>
<p><canvas id="ex17" height="200" width="200" style="border: 1px solid black;"></canvas></p>
<button class="ex17button" data-centerx="-0.7463" data-centery="0.1102" data-r="0.005" >x:-0.7463, y:0.1102, r:0.005</button>
<button class="ex17button" data-centerx="-0.7453" data-centery="0.1127" data-r="0.00065" >x:-0.7453, y:0.1127, r:0.00065</button>
<button class="ex17button" data-centerx="-1.25066" data-centery="0.02012" data-r="0.0005" >x:-1.25066, y:0.02012, r:0.0005</button>
<button class="ex17button" data-centerx="-0.16" data-centery="1.0405" data-r="0.076">x:-0.16, y:1.0405 r:0.046</button>

<script>
(function() {
    var canvasId = "ex17";
    var graph = new Mandelbrot(canvasId);
    graph.iterations = 1500;
    graph.render();
    var buttons =  document.getElementsByClassName(canvasId + "button");
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].onclick = function(e) {
            graph.center = {
                x: parseFloat(e.currentTarget.getAttribute('data-centerx')),
                y: parseFloat(e.currentTarget.getAttribute('data-centery'))
            };
            graph.r = parseFloat(e.currentTarget.getAttribute('data-r'))
            graph.render();
        };
    };
})();
</script>

<p><image src="http://dev.jfo.click/mb/mb50.jpg" /></p>
<p>Alright! This totally works and is beautiful! But, it&#39;s <em>slow.</em> On the one hand
<em>of course it is</em>, this is a lot of computation. But on the other hand... we can do better.</p>
<p>Way, way better.</p>
<p>So, I&#39;ve made a little doodad that computes Mandelbrots on the gpu using WebGL.
It lives here:</p>
<p><a href="http://mandelbrot.jfo.click">http://mandelbrot.jfo.click</a></p>
<p>All of the illustrations above that aren&#39;t example canvases were made with
this tool. I&#39;ve really enjoyed playing with it! You can even resize the canvas
to download high resolution backgrounds as large as you want! Though of course
the bigger they go, the slower they&#39;ll run, but just give it a try and see what
you can find.</p>
<p>I am not going to explain the code in the webgl widget just yet for a few
reasons. First, I&#39;m really happy with how the final product turned out, but the
code is a wreck, organizationally! And anyway, most of it is boilerplate to get
the webgl connected and up and running, and the parts that aren&#39;t boilerplate
aren&#39;t substantially different from the code I&#39;ve shown in vanilla javascript
over the course of this post.</p>
<p>I hacked together this widget using</p>

<ul>
<li><a href="https://webglfundamentals.org">https://webglfundamentals.org</a></li>
</ul>
<p>The author <a href="https://github.com/greggman">Greggman</a> also maintains a library called
<a href="http://twgljs.org/">twgl.js</a> for making the WebGL api less verbose and I am
definitely going to use it next time.</p>

<ul>
<li><a href="https://www.shadertoy.com/view/4df3Rn">https://www.shadertoy.com/view/4df3Rn</a></li>
</ul>
<p>igo Qulez, who created <a href="https://www.shadertoy.com/">shadertoy</a>, also
practically has the <a href="https://www.shadertoy.com/results?query=mandelbrot">market cornered on Mandelbrot
renders</a>. The link above
served as both inspiration for this whole thing (wait... we can compute in
realtime now?) and model while porting my js code over to webgl. I have that
shader to thank for that incredible coloring function that I used as the base
of mine; I&#39;m still not entirely sure how it works.</p>
<p>A few caveats- this isn&#39;t really designed for mobile. UX wise it&#39;s definitely
not, but more importantly mobile platforms don&#39;t seem to have the same caliber
of graphics processing as a lap or desktop. This isn&#39;t really a huge surprise;
you might be able to get it to render something, but no promises.</p>
<p>Also, unfortunately, current
<a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> only natively
supports 32 bit floats for use on the gpu, so we run out of precision
relatively quickly on the widget. You can barely see where the pixels become
blockish at the highest zooms, but don&#39;t be mistaken- this is not the end of
the set- the set goes on <em>forever.</em> There are techniques to work around this
and achieve a higher precision, but my mandelbrot bike shed doesn&#39;t need
<em>another</em> coat of paint before shipping. I&#39;ll likely try to get around to that
sometime, or just put it off until 64 bit floats are native to the platform!</p>
<p><image src="http://dev.jfo.click/mb/mb11.jpg" /></p>
<hr>


<p><span id="references"></span></p>
<h1 id="references">References</h1>
<p>Here are some things I found really helpful while working on this project.</p>

<ul>
<li><p><a href="https://www.youtube.com/watch?v=NGMRB4O922I">Holly Krieger&#39;s explanation of the set on Numberphile</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=56gzV0od6DU">This documentary excerpt featuring Benoit Mandelbrot</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=56gzV0od6DU">Mandelbrot&#39;s Ted talk about roughness from 2010</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=ZDU40eUcTj0">This deep zoom video accompanied by Jonathan Coulton&#39;s song &quot;Mandelbrot Set&quot;</a></p>
</li>
<li><p><a href="http://tilde.club/~david/m/#zoom=6.2260371959942775,3.4&amp;lookAt=-0.6,0&amp;iterations=85&amp;superSamples=1&amp;escapeRadius=10.0&amp;colorScheme=pickColorGrayscale">This JavaScript Mandelbrot generator</a></p>
</li>
<li><p><a href="http://www.wikihow.com/Plot-the-Mandelbrot-Set-By-Hand">This wikihow.com page (I know right? But it was helpful early on!)</a></p>
</li>
<li><p><a href="http://www.cuug.ab.ca/dewara/mandelbrot/Mandelbrowser.html">This collection of interesting coordinates I used for testing.</a></p>
</li>
<li><p><a href="https://searchworks.stanford.edu/view/dd592sd0866">Fractals: an animated discussion</a></p>
</li>
</ul>
<p>Unfortunately the last one is probably the best but I haven&#39;t been able to find
it online anywhere. The one I saw was loaned to me by fellow fractal enthusiast
and Etsian <a href="http://paul-jean.github.io/">Paul-Jean Letourneau</a>. Thanks Paul-Jean!</p>
<blockquote>
<p>Update: <a href="https://fod.infobase.com/p_ViewPlaylist.aspx?AssignmentID=6U4LJA">someone found it!</a></p>
</blockquote>
<p>Also thanks to <a href="https://jvns.ca/">Julia Evans</a> for talking me through some of
the math early on and helping me with my complex number algebra that I kept
messing up and which produced weird blobs on the canvas.</p>
<p>I hope this was interesting. I&#39;m going to shut off my computer for the rest of
the day now. I&#39;ve been thinking of picking one day a week and not looking at
any screens, or at least not staring at the computer screen for the whole day.</p>
<p><image src="http://dev.jfo.click/mb/mb57.jpg" /></p>
<p>(That one is secretely my favorite :))</p>
<div id="update"></div>

<h2 id="sept-2017-update-">Sept 2017 update!</h2>
<p>As part of my self hosting images
<a href="/s3-hugo-and-static-asset-hosting/">initiative</a>, I&#39;ve updated all of the
examples on this page to much more hi-res and web optimized images, and they
look SO GOOD NOW despite being the same weight or lighter than the <a href="https://imgur.com/gallery/15NIE">images I
used to have up here</a>. Special thanks to <a href="https://twitter.com/Lara_Hogan">Lara
Hogan</a> from whose book <a href="http://shop.oreilly.com/product/0636920033578.do">Designing for
Performance</a> I was able to
figure out how to make that quality / size balance work optimally!</p>
</div>
      </article>
    </div>

  </body>
</html>
