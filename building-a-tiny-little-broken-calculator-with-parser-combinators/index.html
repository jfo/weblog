<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Building a tiny little broken calculator with parser combinators</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link
      href="data:image/gif;base64,R0lGODlhEAAQAPMKAAAAAAAAAFBxYfKRAOLSIJGhgfKRkfCxkPKykf7+/v///wAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAAARdEMhAa5UYBMJ7D9nGDQRJcqC2mWVLUtpHIdU3UUoe5MqlEjtFITgEggKIZIU2U04M0KQUakg9DdIk1IoJYJfVTChLE3cFgl0AzZ0g2BR0OqSgpXtpQdltVwj8SFYRADs="
      rel="icon"
    />
    <link href="https://blog.jfo.click/style.css" type="text/css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta property="og:title" content="Building a tiny little broken calculator with parser combinators" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://blog.jfo.click/building-a-tiny-little-broken-calculator-with-parser-combinators" />
    <meta property="og:image" content="https://blog.jfo.click/desk.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@jeffowler" />
  </head>

  <body>
    <div id="content">
      <header class="site-header">
        <h5>jfo</h5> &mdash;
        <a href="https://blog.jfo.click">archive</a> &mdash;
        <a href="https://blog.jfo.click/feed.xml">feed</a> &mdash;
        <a href="mailto:jfo@jfo.click">contact</a>
      </header>

      <article>
        <p></p>
        <h1 class="title-thing">Building a tiny little broken calculator with parser combinators</h1>
        <sub>Jul 25, 2022</sub>
        <p></p>
        <div><p>Perhaps I have a string lying around somewhere...</p>

<pre><code class="lang-js"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">&quot;Abcd123&quot;</span>;
</code></pre>
<p>What a lovely little string.</p>
<p>I will start with a function that takes a string as input and tells you if the
input passes some test you&#39;ve set out for it. This is not yet a parser, not
really. Usually, a parser does quite a lot more than simply return a boolean,
but at its most basic, it <em>must</em> make this binary distinction between</p>

<ol>
<li>Input that matches</li>
<li>Input that does not match</li>
</ol>
<p>So conceptually, this is a good place to start.</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">aParser</span> = input =&gt; input === <span class="hljs-string">&quot;Abcd123&quot;</span>
<span class="hljs-title function_">aParser</span>(testString); <span class="hljs-comment">// true</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">anotherParser</span> = input =&gt; input === <span class="hljs-string">&quot;something else&quot;</span>
<span class="hljs-title function_">anotherParser</span>(testString); <span class="hljs-comment">// false</span>
</code></pre>
<p>That&#39;s not very interesting. Maybe a more interesting question?</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">aMoreInterestingParser</span> = input =&gt; input[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;A&quot;</span>
<span class="hljs-title function_">aMoreInterestingParser</span>(testString); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">aMoreInterestingParser</span>(<span class="hljs-string">&quot;Aadjfiojda&quot;</span>); <span class="hljs-comment">// true</span>
</code></pre>
<p>But what now? What do we <em>do</em> with this return value? It would be more useful
if the return value included something else that can be acted upon, like the
remaining portion of the input...</p>
<p>I can do this quite simply as a little informal tuple:</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">aBetterAndMoreInterestingParser</span> = input =&gt;
  [
    input[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;A&quot;</span>,
    input.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, input.<span class="hljs-property">length</span>)
  ]
<span class="hljs-title function_">aBetterAndMoreInterestingParser</span>(<span class="hljs-string">&quot;Aadjfiojda&quot;</span>); <span class="hljs-comment">// [ true, &#x27;adjfiojda&#x27; ]</span>
<span class="hljs-title function_">aBetterAndMoreInterestingParser</span>(<span class="hljs-string">&quot;Zadjfiojda&quot;</span>); <span class="hljs-comment">// [ false, &#x27;adjfiojda&#x27; ]</span>
</code></pre>
<p>But wait, what if the parser <em>fails</em>? We don&#39;t want to keep parsing the input from
there, we want to try the same place again, don&#39;t we? Then the &quot;remaining
input&quot; should include the current character in this case:</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">aBetterAndMoreInterestingParser</span> = input =&gt; {
  <span class="hljs-keyword">if</span> (input[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;A&quot;</span>) {
    <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, input.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, input.<span class="hljs-property">length</span>)]
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, input]
  }
}
<span class="hljs-title function_">aBetterAndMoreInterestingParser</span>(<span class="hljs-string">&quot;Aadjfiojda&quot;</span>); <span class="hljs-comment">// [ true, &#x27;adjfiojda&#x27; ]</span>
<span class="hljs-title function_">aBetterAndMoreInterestingParser</span>(<span class="hljs-string">&quot;Zadjfiojda&quot;</span>); <span class="hljs-comment">// [ false, &#x27;Zadjfiojda&#x27; ]</span>
</code></pre>
<h2 id="parser-generators">Parser Generators</h2>
<p>A <em>parser generator</em> is a function that returns a parser. Maybe you give it
some input and it decides what to match based on that...</p>

<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseChar</span> = (<span class="hljs-params">char</span>) =&gt;
  <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (input[<span class="hljs-number">0</span>] === char) {
      <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, input.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, input.<span class="hljs-property">length</span>)];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, input];
    }
  };

<span class="hljs-keyword">const</span> parseA = <span class="hljs-title function_">parseChar</span>(<span class="hljs-string">&#x27;A&#x27;</span>);
<span class="hljs-keyword">const</span> parseB = <span class="hljs-title function_">parseChar</span>(<span class="hljs-string">&#x27;B&#x27;</span>);
<span class="hljs-title function_">parseA</span>(testString) <span class="hljs-comment">// [ true, &#x27;bcd123&#x27; ]</span>
<span class="hljs-title function_">parseB</span>(testString) <span class="hljs-comment">// [ false, &#x27;Abcd123&#x27; ]</span>
</code></pre>
<p>Wait wait, I want to back up a bit. I&#39;m describing all these things in plain
english, but I can describe them more succinctly and completely using a type
system. Perhaps I have one of those lying around somewhere...</p>
<h2 id="describing-with-types">Describing with types</h2>
<p>So in this initial (but as of yet incomplete) formulation, a &quot;parser&quot; is a
function that takes a string as input and tells you if the input passes some
test you&#39;ve set out for it. For now, let&#39;s pretend that input is always a
string. It could be binary data or streaming data or some other abstraction
over data, but for now, let&#39;s stick with strings.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = <span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
</code></pre>
<p>Actually, speaking of &quot;other abstractions over data&quot;, here&#39;s a trick... instead
of passing the string around over and over again, I will pass around an object
that references that string and holds and index denoting where the parsing has
progressed to.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Stream</span> = {
  <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">idx</span>: <span class="hljs-built_in">number</span>;
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = <span class="hljs-function">(<span class="hljs-params">s: Stream</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
</code></pre>
<blockquote>
<p>This is pretty similar to how the <code>FILE</code> struct in the C standard library works...</p>

<pre><code class="lang-c"><span class="hljs-comment">// stdio.h</span>
<span class="hljs-keyword">typedef</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">sFILE</span> {</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *_p;    <span class="hljs-comment">/* current position in (some) buffer */</span>
 <span class="hljs-comment">// ...plenty more stuff</span>
} FILE;
</code></pre>
</blockquote>
<p>Again, these should be composable (<em>much</em> more on that later), so the parser
should itself return a stream with its index advanced.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Stream</span> = {
  <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">idx</span>: <span class="hljs-built_in">number</span>;
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = <span class="hljs-function">(<span class="hljs-params">s: Stream</span>) =&gt;</span> <span class="hljs-title class_">Stream</span>;
</code></pre>
<p>What happens if the parser does not match the input?</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Stream</span> = {
  <span class="hljs-attr">src</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">idx</span>: <span class="hljs-built_in">number</span>;
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Stream</span> | <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Parser</span> = <span class="hljs-function">(<span class="hljs-params">s: Stream</span>) =&gt;</span> <span class="hljs-title class_">Result</span>;
</code></pre>
<p>For the moment, I will return <code>undefined</code> for that case, so a <code>Result</code> is a
union type that can either be another <code>Stream</code> or <code>undefined</code>.</p>
<blockquote>
<p>Yes I know this is a poor imitation of <code>Maybe</code>. We&#39;ll get there, maybe.</p>
</blockquote>
<p>So again, a generator is a function that takes some input and returns a <code>Parser</code>. For the
moment, let&#39;s assume that input is also going to be a string, although for
generators, it could really be anything as long as the output is a <code>Parser</code>.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Generator</span> = <span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-title class_">Parser</span>;
</code></pre>
<p>Ok enough with the types, what do these look like in practice?</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">char</span>: <span class="hljs-title class_">Generator</span> = <span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">{ src, idx }</span>) =&gt;</span>
    char === src?.[idx]
      ? { src, <span class="hljs-attr">idx</span>: idx + <span class="hljs-number">1</span> }
      : <span class="hljs-literal">undefined</span>;
</code></pre>
<p>This is a <em>higher order function</em>. A function that returns a function.</p>
<p>This generator takes a <code>string</code> and returns a <code>Parser</code>, which is a function
that takes a <code>Stream</code> and returns a <code>Result</code>.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> parseA = <span class="hljs-title function_">char</span>(<span class="hljs-string">&#x27;A&#x27;</span>)

<span class="hljs-title function_">parseA</span>({
  <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;Abba was a pretty good pop band&quot;</span>,
  <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span>
})
</code></pre>
<p>returns:</p>

<pre><code class="lang-javascript">{
  <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;Abba was a pretty good pop band&quot;</span>,
  <span class="hljs-attr">idx</span>: <span class="hljs-number">1</span>
}
</code></pre>
<p>notice that the <code>idx</code> has been advanced, indicating that the parser was successful.</p>
<p>and...</p>

<pre><code class="lang-javascript"><span class="hljs-title function_">parseA</span>({
  <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;But ELO is really good too&quot;</span>,
  <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span>
})
</code></pre>
<p>returns:</p>

<pre><code>undefined
</code></pre>
<h3 id="parser-combinators">Parser Combinators</h3>
<p>A function that takes some number of parsers and combines them somehow into a
new parser:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">...parsers: Parser[]</span>) =&gt;</span> <span class="hljs-title class_">Parser</span>;
</code></pre>
<p>This is where it gets spicy.</p>
<p>Here is a simple combinator: <code>or</code>.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">or</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">p1, p2</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">p1</span>(input) || <span class="hljs-title function_">p2</span>(input);
  };
};
</code></pre>
<p>Again, a function returning a function, could be written more tersely as:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">or</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> <span class="hljs-title function_">p1</span>(input) || <span class="hljs-title function_">p2</span>(input);
</code></pre>
<p>And so:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> parseA = <span class="hljs-title function_">char</span>(<span class="hljs-string">&#x27;A&#x27;</span>);
<span class="hljs-keyword">const</span> parseB = <span class="hljs-title function_">char</span>(<span class="hljs-string">&#x27;B&#x27;</span>);
<span class="hljs-keyword">const</span> parseAorB = <span class="hljs-title function_">or</span>(parseA, parseB);

<span class="hljs-title function_">parseAorB</span>({<span class="hljs-attr">src</span>: <span class="hljs-string">&quot;Applesauce and orange juice&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span>}); <span class="hljs-comment">// matches!</span>
<span class="hljs-title function_">parseAorB</span>({<span class="hljs-attr">src</span>: <span class="hljs-string">&quot;Buckets of rain&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span>}); <span class="hljs-comment">// matches!</span>
<span class="hljs-title function_">parseAorB</span>({<span class="hljs-attr">src</span>: <span class="hljs-string">&quot;Canada oh Canada&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span>}); <span class="hljs-comment">// does not match :(</span>
</code></pre>
<p>It&#39;s a bit onerous to initialize these <code>Streams</code> everytime, a helper function
for that might be:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> s = (<span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">Stream</span> =&gt;</span> ({ <span class="hljs-attr">src</span>: s, <span class="hljs-attr">idx</span>: <span class="hljs-number">0</span> });
</code></pre>
<p><code>and</code> is a tad bit trickier because we care about how far the first parser has
advanced the index, so we need a reference to it available for the second:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">and</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">p1</span>(input);
    <span class="hljs-keyword">if</span> (r) {
      <span class="hljs-keyword">const</span> r2 = <span class="hljs-title function_">p2</span>(r);
      <span class="hljs-keyword">if</span> (r2) {
        <span class="hljs-keyword">return</span> r2,
      }
    }
  };
</code></pre>

<pre><code class="lang-typescript">parseAandB = <span class="hljs-title function_">and</span>(parseA, parseB);

<span class="hljs-title function_">parseAandB</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;Argyle sweaters&quot;</span>)); <span class="hljs-comment">// does not match :(</span>
<span class="hljs-title function_">parseAandB</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;Beer battered bananas&quot;</span>); <span class="hljs-comment">// does not match :(</span>
<span class="hljs-title function_">parseAandB</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;ABBA&quot;</span>); <span class="hljs-comment">// def matches</span>
</code></pre>
<h2 id="what-is-this-good-for-">What is this good for?</h2>
<p>What I&#39;ve got here so far you could imagine has some practical application for
something like input validation. Let&#39;s say you require a valid input to begin
with <code>&quot;ABBA&quot;</code>, for example:</p>

<pre><code class="lang-typescript">parseAandB = <span class="hljs-title function_">and</span>(parseA, parseB);
parseBandA = <span class="hljs-title function_">and</span>(parseB, parseA);
parseABBA = <span class="hljs-title function_">and</span>(parseAandB, parseBandA)

<span class="hljs-title function_">parseABBA</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;ABBAthis is valid input&quot;</span>);
<span class="hljs-title function_">parseABBA</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;ABBAthis is not&quot;</span>);
</code></pre>
<p>But of course, this is contrived and limited, and not at all what we mean when
we talk about real parsers, real parsers do more than just validate input, they
also return something useful!</p>
<p>Right now, a <code>Result</code> looks like:</p>

<pre><code>type Result = Stream | undefined;
</code></pre>
<p>But actually, we don&#39;t want a <code>Stream</code> by itself, we also want <em>what the parser
matched</em>:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">OutputValue</span> = {
  <span class="hljs-attr">stream</span>: <span class="hljs-title class_">Stream</span>;
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>;
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">OutputValue</span> | <span class="hljs-literal">undefined</span>;
</code></pre>
<p>This necessitates some changes around what the parsers are returning, so for
example, a character parser generator will now look like this:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">char</span>: <span class="hljs-title class_">Generator</span> = <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">{ src, idx }</span>) =&gt;</span>
    c === src?.[idx]
      ? { <span class="hljs-attr">stream</span>: { src, <span class="hljs-attr">idx</span>: idx + <span class="hljs-number">1</span> }, <span class="hljs-attr">value</span>: src[idx] }
      : <span class="hljs-literal">undefined</span>;
</code></pre>
<p>and the <code>and</code> combinator might now look like this:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">and</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">p1</span>(input);
    <span class="hljs-keyword">if</span> (r) {
      <span class="hljs-keyword">const</span> r2 = <span class="hljs-title function_">p2</span>(r.<span class="hljs-property">stream</span>);
      <span class="hljs-keyword">if</span> (r2) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">stream</span>: r2.<span class="hljs-property">stream</span>,
          <span class="hljs-attr">value</span>: [r.<span class="hljs-property">value</span>, r2.<span class="hljs-property">value</span>].<span class="hljs-title function_">flat</span>(),
        };
      }
    }
  };
</code></pre>
<p>In both cases, you can see that I&#39;m returning the matched values in some form.</p>
<p>So now...</p>

<pre><code class="lang-js"><span class="hljs-title function_">parseABBA</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;ABBAthis is valid input&quot;</span>);
</code></pre>
<p>returns:</p>

<pre><code class="lang-js">{
  <span class="hljs-attr">stream</span>: { <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;ABBAthis is valid input&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">4</span> },
  <span class="hljs-attr">value</span>: [ <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span> ]
}
</code></pre>
<p>This is useful because now we can <em>do stuff</em> with the matched values.</p>
<h1 id="a-very-simple-calculator">A very simple calculator</h1>
<p>I want to start by building a <em>very</em> simple calculator that can add two single
digit numbers together. We&#39;ve already got a <code>char</code> parser generator, so we can
pretty easily create all the parsers we need for this:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> zero = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-keyword">const</span> one = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-keyword">const</span> two = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;2&quot;</span>);
<span class="hljs-keyword">const</span> three = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;3&quot;</span>);
<span class="hljs-keyword">const</span> four = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;4&quot;</span>);
<span class="hljs-keyword">const</span> five = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;5&quot;</span>);
<span class="hljs-keyword">const</span> six = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;6&quot;</span>);
<span class="hljs-keyword">const</span> seven = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;7&quot;</span>);
<span class="hljs-keyword">const</span> eight = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;8&quot;</span>);
<span class="hljs-keyword">const</span> nine = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;9&quot;</span>);

<span class="hljs-keyword">const</span> digit = <span class="hljs-title function_">or</span>(nine, <span class="hljs-title function_">or</span>(eight, <span class="hljs-title function_">or</span>(seven, <span class="hljs-title function_">or</span>(six, <span class="hljs-title function_">or</span>(five, <span class="hljs-title function_">or</span>(four, <span class="hljs-title function_">or</span>(three, <span class="hljs-title function_">or</span>(two, <span class="hljs-title function_">or</span>(one, zero)))))))));
</code></pre>
<p>Terribly difficult to read that, isn&#39;t it? I hope the intent is clear, but
that&#39;s not elegant at all. I need something more streamlined...</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">any</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">...ps</span>) =&gt;</span> ps.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-title function_">or</span>(p1, p2));
</code></pre>
<p>This takes any number of parsers and chains the <code>or</code>s just like I&#39;ve done long hand above,</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> digit = <span class="hljs-title function_">any</span>(zero, one, two, three, four, five, six, seven, eight, nine);
</code></pre>
<p>Much clearer, but <code>any</code> also facilitates an easier <code>generator</code> too:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">anyChar</span>: <span class="hljs-title class_">Generator</span> = (str): <span class="hljs-function"><span class="hljs-params">Parser</span> =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> <span class="hljs-title function_">any</span>(...str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">map</span>(char))(input);
</code></pre>
<p>This function takes a string, splits it into its constituent characters, maps
<code>char</code> over them to get parsers, and then reduces <code>or</code> over them via <code>any</code> to
produce a parser that will match any character in a string.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> digit = <span class="hljs-title function_">anyChar</span>(<span class="hljs-string">&quot;0123456789&quot;</span>);
</code></pre>
<p>very compact.</p>
<p>We&#39;ll of course need to match <code>+</code> as well:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> plus = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;+&quot;</span>);
</code></pre>
<p>And now there is enough for a simple expression parser:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">and</span>(digit, <span class="hljs-title function_">and</span>(plus, digit));
</code></pre>
<p>This pattern seems familiar, we can <code>reduce</code> <code>and</code> over arbitrary numbers of
parsers as well, to clean up the syntax a bit:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">andThen</span>: <span class="hljs-title class_">Combinator</span> = <span class="hljs-function">(<span class="hljs-params">...ps</span>) =&gt;</span>
  ps.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-title function_">and</span>(p1, p2));
</code></pre>
<p>So becomes:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">andThen</span>(digit, plus, digit);
</code></pre>
<p>Does this work, then?</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">expression</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;1+2&quot;</span>));
</code></pre>
<p>It does!</p>

<pre><code class="lang-js">{ <span class="hljs-attr">stream</span>: { <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;1+2&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">3</span> }, <span class="hljs-attr">value</span>: [ <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;2&quot;</span> ] }
</code></pre>
<p>This is where things start to get <em>fun</em>.</p>
<p>Each individual parser returns what it matched on, and only what it matched on.
For digits, if it matches, then we know it&#39;s going to be a digit- that&#39;s the
whole point of matching on it. But we don&#39;t really <em>want</em> a string
representation of a digit, do we? We want a <em>real digit</em>.</p>
<p>To get this, we&#39;ll create a new higher order function that</p>

<ol>
<li>takes a parser</li>
<li>takes an arbitrary function</li>
<li>if the parser succeeds, run it&#39;s matched value through the function</li>
</ol>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">map</span> = (<span class="hljs-params">parser: Parser, fn: <span class="hljs-built_in">Function</span></span>) =&gt;
  <span class="hljs-function">(<span class="hljs-params">input: Stream</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> out = <span class="hljs-title function_">parser</span>(input);

    <span class="hljs-keyword">if</span> (out) {
      out.<span class="hljs-property">value</span> = <span class="hljs-title function_">fn</span>(out.<span class="hljs-property">value</span>);
      <span class="hljs-keyword">return</span> out;
    }
  };
</code></pre>
<p>This is general! A simple change to the <code>digit</code> definition above, then</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> digit = <span class="hljs-title function_">map</span>(<span class="hljs-title function_">anyChar</span>(<span class="hljs-string">&quot;0123456789&quot;</span>), <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(n));
</code></pre>
<p>and:</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">expression</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;1+2&quot;</span>));
</code></pre>
<p>returns</p>

<pre><code class="lang-js">{ <span class="hljs-attr">stream</span>: { <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;1+2&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">3</span> }, <span class="hljs-attr">value</span>: [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">2</span> ] }
</code></pre>
<p>Look closely, the digits in the value array are <em>actual javascript digits</em>. This may seem trivial, but I assure you, it&#39;s very powerful!</p>
<p>Consider for a moment: All of these parsers are built up from scratch, and the
functions to which they are mapping their values to are similarly arbitrary.
<code>parseInt</code> is a simple example, but you can do basically anything with the
input as it&#39;s being parsed. Some more thoughts on this later, but I think that
it is this power and flexibility that excites people when they first learn
about combinators.</p>
<p>With the constituent parts of <code>expression</code> now being transformed into
javascript numbers, one more step will do it...</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> calculate = <span class="hljs-title function_">map</span>(expression, <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!value) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> [x, operation, y] = value;

  <span class="hljs-keyword">switch</span> (operation) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>: {
      <span class="hljs-keyword">return</span> x + y;
    }
  }
});
</code></pre>

<pre><code class="lang-typescript"><span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;1+2&quot;</span>)) <span class="hljs-comment">// { stream: { src: &quot;1+2&quot;, idx: 3 }, value: 3 }</span>
<span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;3+4&quot;</span>)) <span class="hljs-comment">// { stream: { src: &quot;3+4&quot;, idx: 3 }, value: 7 }</span>
</code></pre>
<p>I think this is really cool!</p>
<h1 id="an-expanded-expression-parser">An expanded expression parser</h1>
<p>Let&#39;s say we add a few more simple arithmetic operations:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> digit = <span class="hljs-title function_">map</span>(<span class="hljs-title function_">anyChar</span>(<span class="hljs-string">&quot;0123456789&quot;</span>), <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(n));
<span class="hljs-keyword">const</span> plus = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;+&quot;</span>);
<span class="hljs-keyword">const</span> minus = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;-&quot;</span>);
<span class="hljs-keyword">const</span> times = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;*&quot;</span>);
<span class="hljs-keyword">const</span> divide = <span class="hljs-title function_">char</span>(<span class="hljs-string">&quot;/&quot;</span>);
<span class="hljs-keyword">const</span> op = <span class="hljs-title function_">any</span>(divide, times, plus, minus);
<span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">andThen</span>(digit, op, digit)

<span class="hljs-keyword">const</span> calculate = <span class="hljs-title function_">map</span>(expression, <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!value) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> [x, operation, y] = value;

  <span class="hljs-keyword">switch</span> (operation) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>: {
      <span class="hljs-keyword">return</span> x + y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>: {
      <span class="hljs-keyword">return</span> x - y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>: {
      <span class="hljs-keyword">return</span> x * y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>: {
      <span class="hljs-keyword">return</span> x / y;
    }
  }
});
</code></pre>
<p>Very compact! And it will do what it looks like it will do:</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&#x27;1*7&#x27;</span>)); <span class="hljs-comment">// { stream: { src: &quot;1*7&quot;, idx: 3 }, value: 7 }</span>
<span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&#x27;1/4&#x27;</span>)); <span class="hljs-comment">// { stream: { src: &quot;1/4&quot;, idx: 3 }, value: 0.25 }</span>
<span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&#x27;5-2&#x27;</span>)); <span class="hljs-comment">// { stream: { src: &quot;5-2&quot;, idx: 3 }, value: 3 }</span>
</code></pre>
<h1 id="a-small-confession">A small confession</h1>
<p>So we&#39;re all set up for the next section. It&#39;s one of the more interesting
sections, to be honest, so if you&#39;ve made it this far, I hope it will be worth
it.</p>
<p>My small confession is not the next section, it&#39;s a preamble to the next
section, but the confession is that I&#39;ve attempted several times over the last
couple of years, when I had a little time, to grok parser combinators, and I
just kept failing.</p>
<p>Over and over again, I&#39;d watch the videos linked at the bottom of this post,
and think &quot;now I&#39;ve got it!&quot;</p>
<p>And I wouldn&#39;t have got it, and I would try to get them to work and I wouldn&#39;t
be able to, and I&#39;d give up. They&#39;re kind of tricky!</p>
<p>Finally, at this latest attempt, I worked out a few small details that are
quite subtle, but make all the difference. I&#39;m going to describe those problems
and solutions now.</p>
<h1 id="a-slightly-bigger-calculator">A slightly bigger calculator</h1>
<p>We&#39;ve got all four basic arithmetic operations available, what about something
like this?</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&#x27;1+2+3&#x27;</span>));
</code></pre>
<p>It&#39;s quite obvious that this should resolve to 6, and I have parsers for all
the constituent parts, but of course as written, this doesn&#39;t work the way we
would like it to:</p>

<pre><code class="lang-typescript">{ <span class="hljs-attr">stream</span>: { <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;1+2+3&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">3</span> }, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> }
</code></pre>
<p>It only manages to parse the first expression in the series of expressions,
because that&#39;s all we informed it about. An expression is actually a bit more
complicated than that.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">or</span>(<span class="hljs-title function_">andThen</span>(expression, op, digit), digit);
</code></pre>
<p>Now, the above definition of an expression is <em>correct</em>, strictly speaking, but
there are a few things wrong with it, and these things in combination kept me
scratching my head for a long while. Let&#39;s examine the issues one by one.</p>
<p>The first is helpfully pointed out, and pretty obvious as well:</p>

<pre><code>error: TS2448 [ERROR]: Block-scoped variable &#39;expression&#39; used before its declaration.
const expression = or(andThen(expression, op, digit), digit);
</code></pre>
<p><code>expression</code> can&#39;t use itself in it&#39;s own definition, which is on the one hand
sensible, but on the other... well recursive grammars do exist, and in fact
recursive function calls are used all the time... this is really a language
constraint.</p>
<p>But there is an easy solution, and that solution is a thunk!</p>
<p>You wrap an operation in a function, the function is then passed around as a value
instead of the operation. This means that we can specify parts of the recursive
definition that are not evaluated when the grammar is defined, because the
<code>thunk</code>, as this function is called, is not evaluated until it&#39;s invoked. It&#39;s
an elegant way to introduce lazy evaluation to a language that doesn&#39;t have it
built into the syntax.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyAnd</span>(<span class="hljs-params">first: () =&gt; Parser, second: () =&gt; Parser</span>): <span class="hljs-title class_">Parser</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">and</span>(<span class="hljs-title function_">first</span>(), <span class="hljs-title function_">second</span>())(input);
  };
}
</code></pre>
<p>This is not really a combinator, because it doesn&#39;t accept <code>Parser</code>s, it
accepts functions that take no arguments that <em>return</em> <code>Parser</code>s.</p>
<p>Applied to the definition of expression thusly:</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">or</span>(<span class="hljs-title function_">lazyAnd</span>(<span class="hljs-function">() =&gt;</span> expression, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">and</span>(op, digit)), digit);
</code></pre>
<p>And the recursive definition problem is resolved. As far as the runtime is
concerned, by the time the parser is actually <em>invoked</em>, <code>expression</code> has been
defined.</p>
<p>But now, another showstopper:</p>

<pre><code>error: Uncaught RangeError: Maximum call stack size exceeded
const expression = or(lazyAnd(() =&gt; expression, () =&gt; and(op, digit)), digit);
</code></pre>
<p>Stripping away some of the fancy bits here, it does seem fairly obvious that
since <code>expression</code> is the first parser evaluated as a sub part of <code>expression</code>,
that it lacks a base case and will recurse forever.</p>
<p>But at the same time, that&#39;s certainly a valid definition of an expression, right?</p>

<pre><code>expr
----------------
expr, op, digit
----
(1+2)  +  3
</code></pre>
<p>Honestly, this stumped me for a long while. The solution, when I found it, was
so simple and obvious in retrospect...</p>
<p>There is another way to define the same expression!</p>

<pre><code>expr
---------------
digit, op, expr
          -----
1      +  (2+3)
</code></pre>
<p>This is semantically correct as well, <em>but</em> crucially provides a point where
the recursion can be short circuited.</p>

<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">or</span>(<span class="hljs-title function_">lazyAnd</span>(<span class="hljs-function">() =&gt;</span> digit, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">and</span>(op, expression)), digit);
</code></pre>
<p>With a small tweak to the <code>calculate</code> parser and plugging that into the
<code>expression</code> definition, this works for as many terms as desired!</p>

<pre><code class="lang-typescript"><span class="hljs-comment">// Note `calculate` instead of `expression` --------------v</span>
<span class="hljs-keyword">const</span> expression = <span class="hljs-title function_">or</span>(<span class="hljs-title function_">lazyAnd</span>(<span class="hljs-function">() =&gt;</span> digit, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">and</span>(op, calculate)), digit);

<span class="hljs-keyword">const</span> calculate = <span class="hljs-title function_">map</span>(expression, <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!value) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// If an expression can potentially be a bare digit now, `calculate` needs to</span>
  <span class="hljs-comment">// be able to &quot;evaluate&quot; it by returning it directly.</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span>) {
    <span class="hljs-keyword">return</span> value;
  }

  <span class="hljs-keyword">const</span> [x, operation, y] = value;

  <span class="hljs-keyword">switch</span> (operation) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>: {
      <span class="hljs-keyword">return</span> x + y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>: {
      <span class="hljs-keyword">return</span> x - y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>: {
      <span class="hljs-keyword">return</span> x * y;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>: {
      <span class="hljs-keyword">return</span> x / y;
    }
  }
});
</code></pre>
<p>and so:</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;1+2+3+4+5+6+7+8+9&quot;</span>)),
</code></pre>
<p>returns</p>

<pre><code class="lang-js">{ <span class="hljs-attr">stream</span>: { <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;1+2+3+4+5+6+7+8+9&quot;</span>, <span class="hljs-attr">idx</span>: <span class="hljs-number">17</span> }, <span class="hljs-attr">value</span>: <span class="hljs-number">45</span> }
</code></pre>
<p>It&#39;s alive!</p>
<h2 id="some-more-problems">Some more problems</h2>
<p>This little calculator is quite impressive for just a few lines of parsing
code, and shows off how composable and powerful combinators can be, but it is
certainly nothing but a little toy. For example, it has no concept of ordering
the operations in any intelligible way except from rightmost to leftmost:</p>

<pre><code class="lang-typescript"><span class="hljs-title function_">calculate</span>(<span class="hljs-title function_">s</span>(<span class="hljs-string">&quot;2*3+1&quot;</span>)),
</code></pre>
<p>We know this should be interpreted as <code>(2*3)+1 = 7</code> and do the multiplication
first, but the poor simple parser dutifully executes from the bottom of the
stack (the end of the input) to the top (the beginning), and we get <code>2*(3+1) = 8</code>.</p>
<p>The solution to <em>this</em> issue is that, in practice, parsers don&#39;t usually return
arbitrary types of values from their inputs, they return some over-arching
structure like an abstract syntax tree composed of nodes that carry metadata
and thus semantic meaning in context. A real calculator would parse the tree
before evaluating it mathematically, and take into account considerations such
as order of operations <em>then</em>. This parser as written doesn&#39;t keep much state
internally except for where it has advances to in the input, and so decisions
like that can&#39;t be made effectively.</p>
<p>Parsing into an AST is a outside the scope of this post, as it&#39;s already
getting pretty long, though I hope to learn more about that and write about it!
That does seem like the point at which parser combinators become genuinely
useful, and not just fun.</p>
<p>I have also elided the monadic nature of the parsing, though they can
potentially fit quite nicely into that pattern, although it would be necessary
to structure them slightly differently than I have done in this post.</p>
<p>Thanks a LOT to Stefanie Schirmer for helping me work through some of my major
difficulties with these concepts, And my batchmates Ornella Friggit, Isaac
Wilder, and Marcin Jekot for pairing with me extensively, and Julia Evans,
Manuel Odendahl, and Vaibhav Sagar for draft input.</p>
<h2 id="links">Links</h2>


<ul>
<li><a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Understanding Parser Combinators</a>
<ul>
<li><a href="https://vimeo.com/171704565">Understanding Parser Combinators: A Deep Dive</a></li>
</ul>
</li>
<li><a href="https://bodil.lol/parser-combinators/">Learning Parser Combinators With Rust</a></li>
<li><a href="https://www.youtube.com/watch?v=oU2418-8_KI">Stefanie Schirmer - Parsers All The Way Down? Exploring Combinator Parsing</a></li>
</ul>
</div>
      </article>
    </div>

    <script async defer src="https://analytics.jfo.click/latest.js"></script>
    <noscript
      ><img src="https://analytics.jfo.click/noscript.gif" alt=""
    /></noscript>
  </body>
</html>
